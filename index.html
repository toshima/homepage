<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Takaki Oshima's homepage">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <title>Takaki Oshima's homepage</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Source Code Pro', monospace;
      font-size: 15px;
      color: #222222;
    }
    #container {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow: auto;
      line-height: 1.35;
      letter-spacing: 0;
      white-space: pre;
    }
    #container a {
      color: inherit; /* Don't colorize links */
    }
    .pixels {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(4, 1fr);
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    const dance = () => {
      // Update these if font size or font family changes.
      // Couldn't find a reliable way to calculate them on-the-fly.
      const FONT_SIZE = 15;
      const CHAR_WIDTH = FONT_SIZE * 0.6;
      const CHAR_HEIGHT = FONT_SIZE * 1.35;

      // Settings
      const BACKGROUND_COLOR = "#fcfaf3";
      const SPACING = 3; // Minimum number of spaces between text blocks
      const MARGIN_TOP = 0.03; // Margin at top of page
      const MARGIN_BOTTOM = 0.02; // Margin at bottom of page
      const MARGIN_SIDE = 0.05; // Margin on each side of page
      const NUM_STEPS = 200; // Number of steps in the animation. Determines how long the animation lasts.
      const INTERVAL_MS = 15; // Interval between steps in the animation. Determines how fast the characters move.
      const EVOLVE_FRAMES = 500;

      const PFP = [
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [156, 156, 156], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [173, 186, 221], [173, 186, 221], [0, 0, 0], [0, 0, 0], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [66, 71, 85], [173, 186, 221], [173, 186, 221], [173, 186, 221], [173, 186, 221], [63, 76, 119], [63, 76, 119], [63, 76, 119], [173, 186, 221], [173, 186, 221], [0, 0, 0], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [177, 190, 226], [130, 143, 181], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [66, 80, 125], [10, 10, 10], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [64, 77, 121], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [60, 72, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 77, 120], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [173, 186, 221], [173, 186, 221], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [60, 72, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 77, 120], [63, 76, 119], [63, 76, 119], [63, 76, 119], [62, 75, 118], [173, 186, 221], [173, 186, 221], [173, 186, 221], [173, 186, 221], [173, 186, 221], [173, 186, 221], [64, 77, 120], [63, 76, 119], [63, 76, 119], [60, 72, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 77, 120], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [173, 186, 221], [173, 186, 221], [173, 186, 221], [173, 186, 221], [173, 186, 221], [64, 77, 120], [63, 76, 119], [56, 69, 113], [165, 178, 211], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [63, 76, 119], [63, 76, 119], [63, 76, 119], [61, 74, 116], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [2, 3, 2], [67, 80, 123], [173, 186, 221], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [63, 76, 119], [63, 76, 119], [40, 49, 76], [6, 7, 9], [5, 6, 8], [26, 28, 32], [78, 70, 68], [26, 28, 32], [9, 10, 11], [9, 10, 11], [9, 10, 11], [9, 10, 11], [9, 10, 11], [9, 10, 11], [8, 9, 13], [63, 76, 119], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [63, 76, 119], [63, 76, 119], [40, 49, 76], [6, 7, 9], [55, 34, 29], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [6, 7, 9], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [63, 76, 119], [54, 33, 26], [55, 34, 29], [58, 37, 31], [219, 192, 183], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [52, 32, 28], [6, 7, 9], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [63, 76, 119], [54, 33, 26], [118, 94, 88], [216, 189, 180], [158, 132, 123], [69, 56, 54], [90, 75, 71], [158, 132, 123], [148, 113, 103], [148, 113, 103], [96, 76, 71], [69, 56, 54], [92, 77, 73], [92, 77, 73], [52, 32, 28], [6, 7, 9], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [54, 33, 27], [221, 194, 185], [218, 191, 182], [218, 191, 182], [218, 191, 182], [158, 132, 123], [158, 132, 123], [158, 132, 123], [223, 201, 194], [223, 201, 194], [158, 132, 123], [96, 76, 71], [165, 139, 129], [158, 132, 123], [153, 127, 119], [55, 34, 29], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [54, 33, 27], [221, 194, 185], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [158, 132, 123], [158, 132, 123], [223, 201, 194], [223, 201, 194], [158, 132, 123], [158, 132, 123], [158, 132, 123], [154, 128, 119], [211, 184, 175], [55, 34, 29], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [63, 76, 119], [54, 33, 27], [221, 194, 185], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [223, 201, 194], [223, 201, 194], [218, 191, 182], [158, 132, 123], [225, 198, 189], [218, 191, 182], [211, 184, 175], [55, 34, 29], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [31, 35, 44], [55, 34, 28], [221, 194, 185], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [223, 201, 194], [223, 201, 194], [223, 201, 194], [223, 201, 194], [218, 191, 182], [218, 191, 182], [227, 200, 190], [52, 32, 27], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [55, 33, 28], [118, 94, 88], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [148, 113, 103], [148, 113, 103], [148, 113, 103], [148, 113, 103], [217, 190, 181], [218, 191, 182], [227, 200, 190], [52, 32, 27], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [55, 33, 28], [118, 94, 88], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [218, 191, 182], [158, 132, 123], [96, 76, 71], [158, 132, 123], [217, 190, 181], [218, 191, 182], [227, 200, 190], [56, 36, 32], [83, 94, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [55, 33, 28], [118, 94, 88], [218, 191, 182], [218, 191, 182], [218, 191, 182], [158, 132, 123], [158, 132, 123], [165, 124, 118], [165, 121, 117], [158, 132, 123], [158, 132, 123], [225, 198, 189], [227, 200, 190], [54, 34, 29], [31, 35, 44], [83, 94, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [0, 0, 0], [0, 0, 0], [0, 0, 0], [83, 94, 114], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [160, 134, 124], [118, 94, 86], [58, 37, 31], [219, 192, 183], [96, 76, 71], [119, 74, 73], [119, 74, 73], [172, 103, 110], [172, 103, 110], [119, 74, 73], [96, 75, 71], [49, 28, 23], [56, 33, 28], [33, 37, 46], [83, 94, 114], [83, 94, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [83, 94, 114], [83, 94, 114], [31, 35, 44], [83, 94, 114], [31, 35, 44], [31, 35, 44], [160, 134, 124], [158, 132, 123], [156, 130, 121], [54, 33, 28], [158, 132, 123], [158, 132, 123], [158, 132, 123], [96, 76, 71], [96, 76, 71], [158, 132, 123], [158, 132, 123], [42, 21, 17], [56, 33, 28], [33, 37, 46], [83, 94, 114], [83, 94, 114], [83, 94, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [80, 72, 74], [156, 130, 121], [54, 33, 28], [158, 132, 123], [218, 191, 182], [218, 191, 182], [158, 132, 123], [158, 132, 123], [218, 191, 182], [56, 35, 30], [101, 81, 76], [99, 78, 72], [33, 37, 46], [83, 94, 114], [83, 94, 114], [83, 94, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[255, 255, 255], [255, 255, 255], [0, 0, 0], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [80, 72, 74], [158, 132, 123], [158, 132, 123], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [55, 34, 29], [95, 75, 70], [96, 76, 71], [99, 78, 72], [33, 37, 46], [83, 94, 114], [83, 94, 114], [31, 35, 44], [83, 94, 114], [0, 0, 0], [255, 255, 255], [255, 255, 255], [255, 255, 255]],
        [[0, 0, 0], [0, 0, 0], [83, 94, 114], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [33, 36, 45], [158, 132, 123], [158, 132, 123], [96, 76, 71], [96, 76, 71], [96, 76, 71], [158, 132, 123], [158, 132, 123], [96, 76, 71], [22, 29, 40], [31, 35, 44], [33, 37, 46], [83, 94, 114], [31, 35, 44], [31, 35, 44], [83, 94, 114], [31, 35, 44], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
        [[0, 0, 0], [0, 0, 0], [83, 94, 114], [83, 94, 114], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [29, 34, 43], [158, 132, 123], [158, 132, 123], [158, 132, 123], [158, 132, 123], [158, 132, 123], [158, 132, 123], [32, 36, 44], [31, 35, 44], [28, 31, 39], [80, 91, 111], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [83, 94, 114], [83, 94, 114], [83, 94, 114]],
        [[0, 0, 0], [0, 0, 0], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [158, 132, 123], [158, 132, 123], [158, 132, 123], [158, 132, 123], [96, 76, 71], [31, 35, 44], [89, 101, 122], [86, 97, 118], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [31, 35, 44], [83, 94, 114], [83, 94, 114], [83, 94, 114]]
      ];

      const SMALL_DISPLAY_WARNING = "[b]It looks like you're on mobile or have a small display. Fyi the animation looks best viewed on a computer with a larger display.[/b]\n\n";

      // Website content
      const CONTENT = `

        Welcome to the personal homepage of [b]Takaki Oshima[/b].

        ${window.innerWidth < 1000 ? SMALL_DISPLAY_WARNING : ''}
        [b]Work[/b]

        I'm an independent researcher. My interests span a bunch of domains including
         - Creative coding
         - Automated market making protocols
         - Quantitative trading and sports betting
         - AI

        In the past I worked as a SWE at [link https://google.com/]Google[/link] and as a quant trader at an HFT firm. I later cofounded a startup where I researched and built decentralized systems.


        [b]About this website[/b]

        This site is best viewed on a large display. It uses my favourite coding font, [link https://adobe-fonts.github.io/source-code-pro/]source code pro[/link].

        It takes inspiration from the work of generative artists like [link https://ertdfgcvb.xyz/]Andreas Gysin[/link] and more generally from the field of creative coding such as [link https://kimasendorf.com/]Kim Asendorf[/link]'s [link https://github.com/kimasendorf/ASDFPixelSort]pixel sorting algorithm[/link].

        The source code for this website can be found [link https://github.com/toshima/homepage]here[/link].
      `;

      // Remove leading whitespace from each line
      const dedent = (text) => {
        const lines = text.split('\n');
        const nonEmptyLines = lines.filter(line => line.trim());
        if (!nonEmptyLines.length) return text;

        const indentLength = Math.min(...nonEmptyLines.map(line => line.match(/^ */)[0].length));
        return lines.map(line => line.slice(indentLength)).join('\n');
      }

      // Convert pixels (a 2D array of RGB values) into an array of characters with formatting tags
      const getCharsFromPixels = pixels => {
        const toHex = rgbArray => '#' + rgbArray.map(x => x.toString(16).padStart(2, '0')).join('');
        const replaceBg = c => c === "#ffffff" ? BACKGROUND_COLOR : c;

        const chars = [];
        for (let y = 0; y < pixels.length - 1; y += 4) {
          for (let x = 0; x < pixels[y].length; x += 2) {
            const colors = [
              pixels[y][x], pixels[y][x+1], pixels[y+1][x], pixels[y+1][x+1], pixels[y+2][x], pixels[y+2][x+1], pixels[y+3][x], pixels[y+3][x+1]
            ]
            chars.push({
              id: `pixels-${y}-${x}`,
              char: ' ',
              tags: [{name: 'pixels', args: colors.map(toHex).map(replaceBg)}]
            });
          }
          chars.push({
            id: `pixels-${y}-newline`,
            char: '\n',
            tags: []
          });
        }
        return chars;
      }

      // Convert a string into an array of characters with formatting tags
      const getCharsFromText = (text) => {
        const chars = [];
        const activeTags = [];
        const codePoints = [...text]; // Split by unicode code points

        for (let i = 0; i < codePoints.length; i++) {
          if (codePoints[i] === '[' && codePoints.includes(']', i)) {
            const j = codePoints.indexOf(']', i);
            const tag = codePoints.slice(i + 1, j).join('');
            if (tag[0] === '/') {
              // Closing tag: [/tag]
              const tagName = tag.slice(1);
              const index = activeTags.findIndex(t => t.name === tagName);
              if (index !== -1) activeTags.splice(index, 1);
            } else {
              // Opening tag: [tag arg1 arg2]
              const [name, ...args] = tag.split(/\s+/);
              activeTags.push({name, args});
            }
            i = j;
            continue;
          }

          // Regular character
          chars.push({
            id: `text-${i}`,
            char: codePoints[i],
            tags: [...activeTags]
          });
        }
        return chars;
      }

      // Wrap text into lines of maximum width
      const wrapText = (chars, width) => {
        const lines = [];
        let line = [];

        for (const char of chars) {
          if (char.char === '\n') {
            lines.push(line);
            line = [];
            continue;
          }
          line.push(char);

          if (line.length > width) {
            const i = line.findLastIndex(char => char.char === ' ');
            if (i >= 0) {
              lines.push(line.slice(0, i));
              line = line.slice(i + 1);
            } else {
              lines.push(line);
              line = [];
            }
          }
        }

        if (line.length) lines.push(line);
        return lines;
      };

      const populateDOMElements = (chars) => {
        const container = document.getElementById('container');
        for (const char of chars) {
          const element = document.createElement('a');
          element.style.position = 'absolute';
          element.textContent = char.char;
          element.id = `char-${char.id}`;
          element.style.top = `${char.y * CHAR_HEIGHT}px`;
          element.style.left = `${char.x * CHAR_WIDTH}px`;
          element.style.minWidth = `${CHAR_WIDTH}px`;
          element.style.minHeight = `${CHAR_HEIGHT}px`;

          for (const {name, args} of char.tags) {
            if (name === 'link') {
              element.href = args[0];
            } else if (name === 'b') {
              element.style.fontWeight = 'bold';
            } else if (name === 'i') {
              element.style.fontStyle = 'italic';
            } else if (name === 'pixels') {
              element.classList.add('pixels');

              // Define colors
              args.forEach(color => {
                const cell = document.createElement('span');
                cell.style.background = color;
                element.appendChild(cell);
              });
            }
          }

          container.appendChild(element);
        }
      }

      const animate = (t, {frame, nextFrameTime, chars}) => {
        const t0 = performance.now();
        if (t > nextFrameTime) {
          updateMouseVelocity();
          evolveChars({frame, chars});
          updateChars(chars);
          nextFrameTime = t + INTERVAL_MS;
          frame++;
        }
        if (frame % 100 === 0) {
          console.log(`Frame: ${frame} | Time: ${(performance.now() - t0).toFixed(2)}ms`);
        }
        requestAnimationFrame(t => animate(t, {frame, nextFrameTime, chars}));
      }

      const updateMouseVelocity = () => {
        mouseState.velocityX *= 0.9;
        mouseState.velocityY *= 0.9;
        mouseState.velocityX += mouseState.x - mouseState.prevX;
        mouseState.velocityY += mouseState.y - mouseState.prevY;
        mouseState.prevX = mouseState.x;
        mouseState.prevY = mouseState.y;
      }

      const evolveChars = ({frame, chars}) => {
        const t = Math.min(frame / EVOLVE_FRAMES, 1);

        // Map to look up chars by their position
        const positionMap = createPositionMap(chars);

        // Indices of positions that have already moved
        const frozenPositions = new Set();

        const moveChar = (char, y, x) => {
          positionMap[`${char.y},${char.x}`] = null;
          positionMap[`${y},${x}`] = char;
          frozenPositions.add(`${y},${x}`);
          char.y = y;
          char.x = x;
        }

        // Sort so we process characters furthest from their target first
        // This reduces probability of characters getting stuck and not reaching their final position
        const sortedChars = [...chars].sort((a, b) => {
          const distA = Math.abs(a.finalY - a.y) + Math.abs(a.finalX - a.x);
          const distB = Math.abs(b.finalY - b.y) + Math.abs(b.finalX - b.x);

          // Add a bit of randomness to help not get stuck
          return distB - distA + sampleUniform(-3, 3);
        });

        // Freeze links when mouse is nearby
        // A bit hacky but works
        for (const char of sortedChars) {
          const mouseDx = mouseState.x / CHAR_WIDTH - char.x;
          const mouseDy = mouseState.y / CHAR_HEIGHT - char.y;
          const mouseDist = Math.hypot(mouseDx, mouseDy);
          if (
            t > 0.99 && char.tags.some(tag => tag.name === 'link')
            && char.finalY === char.y && char.finalX === char.x
            && mouseDist < 0.05 * numColumns
          ) {
            frozenPositions.add(`${char.y},${char.x}`);
          }
        }

        for (const char of sortedChars) {
          if (frozenPositions.has(`${char.y},${char.x}`)) {
            continue;
          }

          let deltaX = 0;
          let deltaY = 0;

          // Pull towards final position. Starts at time 0.25 - 0.75 depending on weight and ends at time 1
          const finalPullWeight = Math.max(0, (t - 0.75 + char.weight * 0.5) / 0.75);
          deltaX += finalPullWeight * (char.finalX - char.x);
          deltaY += finalPullWeight * (char.finalY - char.y);

          // Add rotation around center. Ramps down from time 0 to time 0.8.
          const centerDx = numColumns / 2 - char.x;
          const centerDy = numRows / 2 - char.y;
          const centerDist = Math.hypot(centerDx, centerDy);
          if (centerDist > 0) {
            const centerRotationWeight = Math.max(0, 0.8 - t) / 0.8;
            deltaX += centerRotationWeight * centerDy / centerDist;
            deltaY += centerRotationWeight * -centerDx / centerDist;
          }

          // Rain
          // const rainWeight = Math.max(0, 0.6 - t + sampleUniform(-0.05, 0.05)) / 0.6;
          // if (t > 0.2) {
          //   deltaX += rainWeight;
          //   deltaY += rainWeight;
          // }

          // Add mouse influence
          const mouseDx = mouseState.x / CHAR_WIDTH - char.x;
          const mouseDy = mouseState.y / CHAR_HEIGHT - char.y;
          const mouseDist = Math.hypot(mouseDx, mouseDy);
          const maxMouseDist = 8;
          if (mouseDist / maxMouseDist < 1 - char.weight && mouseState.seen) { // Only affect characters within range
            const mouseSpeed = Math.hypot(mouseState.velocityX / CHAR_WIDTH, mouseState.velocityY / CHAR_HEIGHT);
            const mouseSpeedWeight = Math.min(mouseSpeed / 100, 1);
            deltaX += 100 * mouseSpeedWeight / mouseDist * mouseDx;
            deltaY += 100 * mouseSpeedWeight / mouseDist * mouseDy;

            deltaX += 100 * mouseSpeedWeight * mouseState.velocityX / mouseSpeed;
            deltaY += 100 * mouseSpeedWeight * mouseState.velocityY / mouseSpeed;

            // Add clockwise curl effect around mouse
            // deltaX += 20 * -mouseSpeedWeight * mouseDy / mouseDist; 
            // deltaY += 20 * mouseSpeedWeight * mouseDx / mouseDist;
          }

          // Explosion
          // if (frame === Math.floor(0.5 * EVOLVE_FRAMES)) {
          //   console.log('exploding');
          //   char.driftX += -centerDx / centerDist;
          //   char.driftY += -centerDy / centerDist;
          // }

          // Drift
          // const driftProb = 0.001;// * Math.max(0, 1 - t);
          // if (Math.random() < driftProb && t < 1) {
          //   char.driftX += Math.random() < 0.5 ? sampleUniform(-1, 1) : 0;
          //   char.driftY += Math.random() < 0.5 ? sampleUniform(-1, 1) : 0;
          // }
          // deltaX += 100 * char.driftX;
          // deltaY += 100 * char.driftY;
          // char.driftX *= t < 1 ? 0.99 : 0.8;
          // char.driftY *= t < 1 ? 0.99 : 0.8;

          // If it doesn't move much, just skip and mark it as frozen
          if (Math.hypot(deltaX, deltaY) < 0.001) {
            frozenPositions.add(`${char.y},${char.x}`);
            continue;
          }

          // Move character one step in the direction of the force, adding a bit of randomness
          const theta = Math.atan2(deltaY, deltaX) + sampleUniform(-Math.PI / 4, Math.PI / 4);
          const diagonalMoveAllowed = true;
          const angleStep = diagonalMoveAllowed ? Math.PI / 4 : Math.PI / 2;
          const discretizedTheta = Math.round(theta / angleStep) * angleStep;

          // Calculate direction of movement based on theta
          const newY = (char.y + Math.round(Math.sin(discretizedTheta)) + numRows) % numRows;
          const newX = (char.x + Math.round(Math.cos(discretizedTheta)) + numColumns) % numColumns;

          // If there is a character and it has already moved, don't move this character
          const key = `${newY},${newX}`;
          if (frozenPositions.has(key)) {
            continue;
          }

          // Check to see if there's already a character in the position we want to move to
          // Swap positions with target character if it exists
          const targetChar = positionMap[key];
          if (targetChar) {
            moveChar(targetChar, char.y, char.x);
          }

          moveChar(char, newY, newX);
        }
      };

      const updateChars = (chars) => {
        const container = document.getElementById('container');
        for (const char of chars) {
          const element = document.getElementById(`char-${char.id}`);
          element.style.top = `${char.y * CHAR_HEIGHT}px`;
          element.style.left = `${char.x * CHAR_WIDTH}px`;
        }
      }

      // Create a map to look up chars by their y and x for efficient lookup
      const createPositionMap = chars => {
        const positionMap = {};
        chars.forEach(char => {
          const key = `${char.y},${char.x}`;
          positionMap[key] = char;
        });
        return positionMap;
      }

      // Random sampling functions
      const sampleUniform = (min, max) => min + Math.random() * (max - min);
      const sampleUniformInt = (min, max) => Math.floor(sampleUniform(min, max + 1));
      const sampleExponential = lambda => -Math.log(Math.random()) / lambda;

      // Set background color
      document.body.style.background = BACKGROUND_COLOR;

      // Mouse state
      const mouseState = {
        x: 0,
        y: 0,
        prevX: 0,
        prevY: 0,
        velocityX: 0,
        velocityY: 0,
        seen: false
      };
      document.addEventListener('mousemove', (e) => {
        mouseState.x = e.clientX;
        mouseState.y = e.clientY;
        mouseState.seen = true;
      });

      // Calculate number of columns and min rows based on window size.
      const numRows = Math.floor(window.innerHeight / CHAR_HEIGHT) - 1;
      const numColumns = Math.floor(window.innerWidth / CHAR_WIDTH) - 1;

      // Parse the website text and wrap it into lines
      const pfpChars = getCharsFromPixels(PFP);
      const contentChars = getCharsFromText(dedent(CONTENT));
      let chars = [...pfpChars, ...contentChars];

      // Calculate number of columns to wrap text into
      // It's between 50% and 80% depending on the window width
      const sizeWeight = Math.min(1, Math.max(0, (window.innerWidth - 600) / 1000));
      const numWrapColumns = Math.ceil(numColumns * (0.5 * sizeWeight + 0.8 * (1 - sizeWeight)));

      // Wrap the text into lines and attach final positions
      const lines = wrapText(chars, numWrapColumns);
      const startY = Math.max(5, Math.floor((numRows - lines.length) * 0.4));
      const startX = Math.floor((numColumns - numWrapColumns) * 0.5);
      for (let y = 0; y < lines.length; y++) {
        for (let x = 0; x < lines[y].length; x++) {
          const char = lines[y][x];
          char.finalY = y + startY;
          char.finalX = x + startX;
        }
      }

      // Remove chars not assigned a final position, such as spaces that were wrapped
      chars = chars.filter(c => c.finalX !== undefined && c.finalY !== undefined);

      // Remove whitespace chars
      chars = chars.filter(c => (c.char !== ' ' && c.char !== '\n') || c.tags.length > 0);

      // Set initial positions and weights
      for (const char of chars) {
        char.y = sampleUniformInt(0, numRows);
        char.x = sampleUniformInt(0, numColumns);
        char.driftY = Math.random() < 0.01 ? sampleUniform(-1, 1) : 0;
        char.driftX = Math.random() < 0.01 ? sampleUniform(-1, 1) : 0;
        char.weight = sampleUniform(0, 1);
      }

      populateDOMElements(chars);
      requestAnimationFrame(t => animate(t, {frame: 0, nextFrameTime: 0, chars}));
    }

    document.fonts.ready.then(dance);
  </script>
</body>
</html>