<!DOCTYPE html>
<html>
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
      <title>takaki oshima's personal homepage</title>
      <style>
            html, body {
                  height: 100%;
                  margin: 0;
                  padding: 0;
            }
            body {
                  font-family: 'Source Code Pro', monospace;
                  font-size: 15px;
                  background: #f9f9f9;
                  color: #222222;
            }
            #container {
                  margin: 0;
                  padding: 0;
                  min-height: 100vh;
                  overflow: auto;
                  line-height: 1.3;
                  letter-spacing: 0;
                  white-space: pre;
            }
      </style>
</head>
<body>
      <div id="container"></div>
      <script>
            const dance = () => {
                  // Update this if font size or font family changes
                  // I couldn't find a reliable way to calculate these on-the-fly
                  const CHAR_WIDTH = 15 * 0.6;
                  const CHAR_HEIGHT = 15 * 1.3;

                  // Settings
                  const MARGIN_TOP = 0.03; // Margin at top of page
                  const MARGIN_BOTTOM = 0.02; // Margin at bottom of page
                  const MARGIN_SIDE = window.innerWidth < 1000 ? 0.1 : 0.2; // Margin on each side of page
                  const NUM_STEPS = 200; // Number of steps in the simulation
                  const INTERVAL_MS = 60; // Interval between steps in the simulation

                  const CAT_TOKENS = ["⚈", "⚆", "⚉"]; // Tokens to be replaced with cat faces
                  const CAT_FACES = ["-^-", "o^o", "-^0", "0^-", "'^'", "'^'", "'^'", "0^0"]; // Possible cat faces
                  let currentCatFace = "o^o";

                  // Website content
                  const CONTENT = [
                        "welcome to the personal homepage of [b]takaki oshima[/b]",
                        `
                              (this website is still a work-in-progress)
                        `,
                        `
                              work
                              ~~~~
                              hi, i'm an independent researcher. my interests span a bunch of domains including
                                - ai
                                - automated market making protocols
                                - quantitative sports betting
                                - creative coding

                              in the past i worked as a swe at [google](https://google.com/) and later as an hft trader. i also cofounded a startup and researched and designed decentralized protocols there.
                        `,
                        `
                              how i made this
                              ~~~~~~~~~~~~~~~
                              the algorithm behind this website works by giving each character (including blank spaces) a random velocity and mass. then each 2x2 square is rotated clockwise or counterclockwise depending on the angular momentum of the 4 characters. to get the characters to end up in their final positions, a simulation is first played out and the target text is written out, then the characters are reset back to their original positions and the algorithm is run again for real.

                              if you refresh the page and rerun the algorithm, it'll be different every time. stuff like the starting positions of the characters are all randomized. the positions of the text and the background color will also be different.
                        `,
                        `
                              books
                              ~~~~~
                              below are my favourite books or books which have influenced me in some way. in no particular order.
                                - what i talk about when i talk about running by haruki murakami
                                - folding beijing by hao jingfang
                                - siddhartha by hermann hesse
                                - the three body problem series by liu cixin
                                - the almanack of naval ravikant by eric jorgenson
                                - sapiens by yuval noah harari
                                - the dispossessed by ursula k. le guin
                        `,
                        `
                              i like tea, especially peppermint and ali shan.
                        `,
                        `
                              about this website
                              ~~~~~~~~~~~~~~~~~~
                              this site was written in pure javascript. best viewed on a large display. it uses my favourite coding font, [source code pro](https://adobe-fonts.github.io/source-code-pro/).

                              the design and algorithm behind this website takes inspiration from the work of generative artists like [andreas gysin](https://ertdfgcvb.xyz/) and from [kim asendorf](https://kimasendorf.com/)'s [pixel sorting algorithm](https://github.com/kimasendorf/ASDFPixelSort).
                        `,
                        `
                              ai seems to be getting really good really quickly. my basic framework is to
                                1. use ai for the things it can do (eg tools like cursor)
                                2. use my time doing things it can't do yet (eg building a business)
                        `,
                        `
                               /\\_/\\
                              ( ⚈.⚉ )
                                 ⚆
                        `,
                        `
                              socials
                              ~~~~~~~
                              you can find me on [github](https://github.com/toshima/) and (less actively) on [twitter](https://x.com/takakioshima) and [linkedin](https://www.linkedin.com/in/takakioshima/).
                        `,
                  ];

                  // Remove leading whitespace from each line
                  function dedent(text) {
                        const lines = text.split('\n');
                        const indentLength = Math.min(...lines.filter(line => line.trim()).map(line => line.match(/^ */)[0].length));
                        return lines.map(line => line.slice(indentLength)).join('\n');
                  }

                  // Take in a string and return an array of characters together with their formatting.
                  // For example, "[b]h[/b]i" -> [{char: "h", link: null, bold: true}, {char: "i", link: null, bold: false}]
                  function parseFormattedCharacters(input) {
                        const chars = [...input]; // This splits correctly for multi-byte characters like emojis
                        const result = [];
                        let i = 0;
                        while (i < chars.length) {
                              if (chars[i] === '[') {
                                    if (chars.slice(i, i + 3).join('') === '[b]') {
                                          const j = chars.indexOf('[', i + 3);
                                          if (j !== -1 && chars.slice(j, j + 4).join('') === '[/b]') {
                                                const boldText = chars.slice(i + 3, j);
                                                for (const char of boldText) {
                                                      result.push({char, link: null, bold: true});
                                                }
                                                i = j + 4; // Skip past "[/b]"
                                                continue;
                                          }
                                    }
                                    const j = chars.indexOf(']', i + 1);
                                    const k = chars.indexOf(')', i + 1);
                                    if (j !== -1 && k !== -1 && chars[j+1] === "(") {
                                          const linkText = chars.slice(i + 1, j).join('');
                                          const linkUrl = chars.slice(j + 2, k).join('');
                                          for (const char of linkText) {
                                                result.push({char, link: linkUrl, bold: false});
                                          }
                                          i = k + 1; // Skip past ")"
                                          continue;
                                    }
                              }
                              result.push({char: chars[i], link: null, bold: false});
                              i++;
                        }
                        return result;
                  }

                  // Take in an array of formatted characters and return an array of lines,
                  // splitting when the text is too long
                  const wrapText = (formattedChars, width) => {
                        const lines = [];
                        let line = [];
                        let lastSpaceIdx = -1;
                        for (const fc of formattedChars) {
                              if (fc.char === '\n') {
                                    lines.push(line);
                                    line = [];
                                    lastSpaceIdx = -1;
                                    continue;
                              }
                              line.push(fc);
                              if (fc.char === ' ') {
                                    lastSpaceIdx = line.length - 1;
                              }
                              if (line.length >= width) {
                                    if (lastSpaceIdx >= 0) {
                                          lines.push(line.slice(0, lastSpaceIdx));
                                          line = line.slice(lastSpaceIdx + 1);
                                    } else {
                                          lines.push(line);
                                          line = [];
                                          lastSpaceIdx = -1;
                                    }
                              }
                        }
                        if (line.length) {
                              lines.push(line);
                        }
                        return lines;
                  };

                  const updateTextBlockPositions = (rectangles, numColumns) => {
                        // Calculate the margins in terms of the number of columns
                        const ms = Math.max(1, Math.floor(MARGIN_SIDE * numColumns));
                        const mt = Math.max(1, Math.floor(MARGIN_TOP * numColumns));

                        for (const [i, rectangle] of rectangles.entries()) {
                              const {width, height} = rectangle;
                              for (let row = mt; row < mt + 10_000; row += 1) {
                                    const column = sampleUniformInt(ms, numColumns - width - ms);
                                    if (!rectangles.slice(0, i).some(r => 
                                          column < r.column + r.width + 2 && 
                                          column + width > r.column - 2 &&
                                          row < r.row + r.height + 2 && 
                                          row + height > r.row - 2
                                    )) {
                                          rectangle.row = row;
                                          rectangle.column = column;
                                          break;
                                    }
                              }
                        }
                  }

                  // Get the width of a monospace character in pixels
                  // const getMonospaceWidth = (fontSize, fontFamily) => {
                  //       const canvas = document.createElement('canvas');
                  //       const context = canvas.getContext('2d');
                  //       context.font = `${fontSize}px "${fontFamily}"`;
                  //       const metrics = context.measureText('M');
                  //       return metrics.width;
                  // }

                  const generateCells = (numRows, numColumns) => {
                        const cells = [];
                        for (let r = 0; r < numRows; r++) {
                              for (let c = 0; c < numColumns; c++) {
                                    // `stopStep` is the step at which the character will no longer move.
                                    // We set it so that the characters are finalized in a sweeping motion from top-left to bottom-right.
                                    const progress = (r + c) / (numRows + numColumns);
                                    const stopStep = Math.floor(progress * NUM_STEPS);
                                    cells.push({
                                          initialRow: r,
                                          initialColumn: c,
                                          formattedChar: {char: ' ', link: null, bold: false},
                                          mass: sampleExponential(1),
                                          rowVelocity: sampleGaussian(),
                                          columnVelocity: 3 * sampleGaussian(),  // We want more horizontal movement than vertical
                                          stopStep,
                                          row: r,
                                          column: c,
                                    });
                              }
                        }
                        return cells;
                  }

                  const simulateAndPopulateCellChars = (cells, numRows, numColumns, textBlocks) => {
                        // Create a copy of the cells so we don't actually move the original cells
                        const simulationState = {
                              cells: cells.map(cell => ({...cell})),
                              numRows,
                              numColumns,
                              step: 0,
                        }

                        // Simulate all the steps without displaying anything
                        for (let i = 0; i < NUM_STEPS; i++) {
                              evolve(simulationState);
                              simulationState.step += 1;
                        }

                        // Create mapping to speed things up
                        const simulatedCellMap = createCellMap(simulationState.cells);
                        const cellMap = createCellMap(cells);

                        // Populate the cells with the characters from the simulation
                        for (const block of textBlocks) {
                              for (const [r, line] of block.lines.entries()) {
                                    // Random shift to avoid the left side of the text exactly lining up
                                    const offset = 0; //`sampleUniformInt(0, 1);
                                    for (const [c, formattedChar] of line.entries()) {
                                          // Find the cell that ended up in this position in the simulation
                                          const simCell = simulatedCellMap[`${block.row + r},${block.column + c + offset}`];
                                          if (simCell) {
                                                // Update the cell in the simulated cell's initial position
                                                const cell = cellMap[`${simCell.initialRow},${simCell.initialColumn}`];
                                                cell.formattedChar = formattedChar;
                                          }
                                    }
                              }
                        }
                  }

                  // Update the container with multiple lines of random text
                  const update = (state) => {
                        evolve(state);
                        display(state);
                        state.step += 1;

                        // Change the cat face at random intervals
                        if (Math.random() < 0.5 && state.step % 50 === 0) {
                              currentCatFace = CAT_FACES[Math.floor(Math.random() * CAT_FACES.length)];
                        }

                        // We keep running after NUM_STEPS has elapsed so the cat face can keep changing
                        // But after 10 * NUM_STEPS, we stop running
                        if (state.step >= 10 * NUM_STEPS) {
                              clearInterval(intervalId);
                              return;
                        }
                  }

                  // Update the webpage with the current state of the simulation
                  const display = ({cells, step}) => {
                        let lines = [];
                        for (let r = 0; r < numRows; r++) {
                              const rowCells = cells.filter(cell => cell.row === r).sort((a, b) => a.column - b.column);
                              lines.push(rowCells.map(({formattedChar: {char, link, bold}, stopStep}) => {
                                    if (bold) {
                                          return `<strong>${char}</strong>`;
                                    } else if (link && step >= stopStep) {
                                          // Only show links after they're in their final position
                                          return `<a href="${link}" style="color: inherit; text-decoration: underline;">${char}</a>`;
                                    } else if (CAT_TOKENS.includes(char)) {
                                          // Replace the token with the corresponding one in the current cat face
                                          return currentCatFace[CAT_TOKENS.indexOf(char)];
                                    } else {
                                          return char;
                                    }
                              }).join(''));
                        }
                        const container = document.getElementById('container');
                        container.innerHTML = lines.join('\n');
                  }

                  // Update the simulation state by one step
                  const evolve = (state) => {
                        const {cells, numRows, numColumns, step} = state;
                        const cellMap = createCellMap(cells);

                        // We look at tilings of 2x2 squares of cells, alternating between starting at (0, 0) and (1, 1)
                        for (let r = step % 2; r < numRows-1; r += 2) {
                              for (let c = step % 2; c < numColumns-1; c += 2) {
                                    const group = [
                                          cellMap[`${r},${c}`],
                                          cellMap[`${r},${(c + 1)}`],
                                          cellMap[`${(r + 1)},${(c + 1)}`],
                                          cellMap[`${(r + 1)},${c}`],
                                    ];
                                    if (group.some(({stopStep}) => step >= stopStep)) {
                                          continue;
                                    }

                                    const clockwise = calculateAngularMomentum(group) < 0;
                                    if (clockwise) {
                                          group[0].row += 1;
                                          group[1].column -= 1;
                                          group[2].row -= 1;
                                          group[3].column += 1;
                                    } else {
                                          group[0].column += 1;
                                          group[1].row += 1;
                                          group[2].column -= 1;
                                          group[3].row -= 1;
                                    }
                              }
                        }
                  }

                  const calculateAngularMomentum = (group) => {
                        const centerRow = group.reduce((sum, cell) => sum + cell.row, 0) / group.length;
                        const centerColumn = group.reduce((sum, cell) => sum + cell.column, 0) / group.length;
                        let angularMomentum = 0;
                        for (const cell of group) {
                              const dr = cell.row - centerRow;
                              const dc = cell.column - centerColumn;
                              angularMomentum += cell.mass * (dr * cell.columnVelocity - dc * cell.rowVelocity);
                        }
                        return angularMomentum;
                  }

                  // Create a map to look up cells by their row and column
                  const createCellMap = (cells) => {
                        const cellMap = {};
                        cells.forEach(cell => {
                              cellMap[`${cell.row},${cell.column}`] = cell;
                        });
                        return cellMap;
                  }

                  const sampleBackgroundColor = () => {
                        const r = sampleUniformInt(245, 255);
                        const g = sampleUniformInt(245, 255);
                        const b = sampleUniformInt(245, 250);
                        return `rgb(${r}, ${g}, ${b})`;
                  }

                  const sampleUniform = (min, max) => {
                        return min + Math.random() * (max - min);
                  }

                  const sampleUniformInt = (min, max) => {
                        return Math.floor(sampleUniform(min, max + 1));
                  }

                  const sampleExponential = (lambda) => {
                        return -Math.log(Math.random()) / lambda;
                  }

                  const sampleGaussian = () => {
                        const r = Math.sqrt(sampleExponential(2));
                        const theta = 2 * Math.PI * Math.random();
                        return r * Math.cos(theta);
                  }

                  // Calculate number of columns and min rows based on window size.
                  // Subtract 1 so we don't see scrollbars.
                  const numColumns = Math.floor(window.innerWidth / CHAR_WIDTH) - 1;
                  const minRows = Math.floor(window.innerHeight / CHAR_HEIGHT) - 1;

                  // Parse the website text and wrap it into lines
                  const textBlocks = CONTENT.map(string => {
                        const text = parseFormattedCharacters(dedent(string));
                        const minWidth = string.length > 100 ? 30 : 20;
                        const maxWidth = Math.min(numColumns * (1 - 2 * MARGIN_SIDE), 60);
                        const width = sampleUniformInt(minWidth, maxWidth);
                        const lines = wrapText(text, width);
                        return {
                              lines,
                              width,
                              height: lines.length,
                        }
                  });
                  updateTextBlockPositions(textBlocks, numColumns);

                  // Calculate the number of rows based on the block positions
                  const numRows = Math.max(minRows, Math.max(...textBlocks.map(block => block.row + block.height)) + Math.floor(MARGIN_BOTTOM * numColumns));

                  // Generate the cells and simulate the movement of the characters
                  const cells = generateCells(numRows, numColumns);
                  simulateAndPopulateCellChars(cells, numRows, numColumns, textBlocks);

                  // Sample and set a random background color
                  document.body.style.backgroundColor = sampleBackgroundColor();

                  // Run and display the simulation
                  const state = {cells, numRows, numColumns, step: 0};
                  display(state);
                  const intervalId = setInterval(() => update(state), INTERVAL_MS);
            }

            document.fonts.ready.then(() => {
                  dance();
            });
      </script>
</body>
</html>
