<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Takaki Oshima's homepage">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <title>Takaki Oshima's homepage</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Source Code Pro', monospace;
      font-size: 15px;
      color: #222222;
    }
    #container {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow: auto;
      line-height: 1.35;
      white-space: pre;
    }
    #container a {
      color: inherit; /* Don't colorize links */
    }
    .pixels {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(4, 1fr);
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    document.fonts.ready.then(() => {
      // Remove leading whitespace from each line
      const dedent = (text) => {
        const lines = text.split('\n');
        const nonEmptyLines = lines.filter(line => line.trim());
        if (!nonEmptyLines.length) return text;

        const indentLength = Math.min(...nonEmptyLines.map(line => line.match(/^ */)[0].length));
        return lines.map(line => line.slice(indentLength)).join('\n');
      }

      const config = {
        fontSize: 15,
        charWidth: 15 * 0.6,
        charHeight: 15 * 1.35,
        backgroundColor: "#ffebf4",
        maxFrame: 400, // Number of frames to evolve the characters for.
        intervalMs: 15, // Interval between steps in the animation. Determines how fast the characters move.
        content: dedent(`

          Welcome to the personal homepage of [b]Takaki Oshima[/b].


          [b]Work[/b]

          I'm an independent researcher. My interests span a bunch of domains including
          - Creative coding
          - Automated market making protocols
          - Quantitative trading and sports betting
          - AI

          In the past I worked as a SWE at [link https://google.com/]Google[/link] and as a quant trader at an HFT firm. I later cofounded a startup where I researched and built decentralized systems.


          [b]About this website[/b]

          This site is best viewed on a large display. It uses my favourite coding font, [link https://adobe-fonts.github.io/source-code-pro/]Source Code Pro[/link].

          It takes inspiration from the work of generative artists like [link https://ertdfgcvb.xyz/]Andreas Gysin[/link] and more generally from the field of generative art.

          The source code for this website can be found [link https://github.com/toshima/homepage]here[/link]. This site was last updated [i]March 2025[/i].


          [b]Socials[/b]

          I don't use social media much but I have accounts on [link https://github.com/toshima/]Github[/link] and (less actively) on [link https://x.com/takakioshima/]Twitter[/link] and [link https://www.linkedin.com/in/takakioshima/]LinkedIn[/link].


           /\\_/\\
          ( [eye]-[/eye].[eye]-[/eye] )
             ^
        `),
        pfpImage: {
          columns: 32,
          colors: ['#000000', '#020302', '#050608', '#060709', '#08090d', '#090a0b', '#0a0a0a', '#161d28', '#1a1c20', '#1c1f27', '#1d222b', '#1f232c', '#20242c', '#21242d', '#21252e', '#28314c', '#2a1511', '#311c17', '#34201b', '#34201c', '#35211c', '#36211a', '#36211b', '#36211c', '#36221d', '#37221c', '#37221d', '#38211c', '#38231e', '#382420', '#384571', '#3a251f', '#3c4872', '#3d4a74', '#3e4b76', '#3f4c77', '#3f4d78', '#404d78', '#404d79', '#424755', '#42507d', '#43507b', '#453836', '#4e4644', '#50484a', '#505b6f', '#535e72', '#566176', '#59657a', '#5a4b47', '#5c4d49', '#5f4b46', '#604b47', '#604c47', '#634e48', '#65514c', '#765e56', '#765e58', '#774a49', '#828fb5', '#947167', '#997f77', '#9a8077', '#9c8279', '#9c9c9c', '#9e847b', '#a0867c', '#a57975', '#a57c76', '#a58b81', '#a5b2d3', '#ac676e', '#adbadd', '#b1bee2', '#d3b8af', '#d8bdb4', '#d9beb5', '#dabfb6', '#dbc0b7', '#ddc2b9', '#dfc9c2', '#e1c6bd', '#e3c8be', '#ffffff'],
          image: 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\x00\x00SSSSSSSSSSSSSSSSSSSSSSSSS@\x00\x00\x00\x00HH\x00\x00\x00SSSSSSSSSSSSSSSSSSSSS\x00\'HHHH###HH\x00\x00SSSSSSSSSSSSSSSSSS\x00I;##########(\x06SSSSSSSSSSSSSSSSS\x00&############ \x00SSSSSSSSSSSSSSS\x00$#######HH#### \x00SSSSSSSSSSSSSSS\x00$###"HHHHHH%## \x00SSSSSSSSSSSSSSS\x00$#####HHHHH%#\x1eF\x00SSSSSSSSSSSSSS\x00####!\x03\x03\x03\x03\x03\x03\x03\x03\x03\x01)H\x00SSSSSSSSSSSSS\x00###\x0f\x03\x02\x08+\x08\x05\x05\x05\x05\x05\x05\x04#\x00SSSSSSSSSSSSS\x00###\x0f\x03\x1a\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x00SSSSSSSSSSSSS\x00##\x15\x1a\x1fN\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x13\x03\x00SSSSSSSSSSSSS\x00##\x159KA*1A<<5*22\x13\x03\x00SSSSSSSSSSSSS\x00#\x16OMMMAAAPPA5EA=\x1a\x00SSSSSSSSSSSSS\x00#\x16OMMMMAAPPAAA>J\x1a\x00SSSSSSSSSSSSS\x00#\x16OMMMMMMPPMAQMJ\x1a\x00SSSSSSSSSSSS\x00.\x0b\x19OMMMMMPPPPMMR\x12\x00SSSSSSSSSSSS\x00..\x0b\x0b\x149MMMM<<<<LMR\x12\x00SSSSSSSSSSSS\x00..\x0b\x0b\x149MMMMMA5ALMR\x1d.\x00SSSSSSSSSSS\x00..\x0b\x0b\x149MMMAADCAAQR\x18\x0b.\x00SSSSSSS\x00\x00\x00...\x0b\x0bB8\x1fN5::GG:4\x11\x1b\x0e..\x00SSSSSSS\x00...\x0b.\x0b\x0bBA?\x17AAA55AA\x10\x1b\x0e...\x00SSSSSS\x00...\x0b\x0b\x0b\x0b\x0b,?\x17AMMAAM\x1c76\x0e...\x00SSSSSS\x00..\x0b\x0b\x0b\x0b\x0b\x0b,AA\x1a\x1a\x1a\x1a\x1a\x1a356\x0e..\x0b.\x00SSS\x00\x00...\x0b\x0b\x0b\x0b\x0b\x0b\x0b\rAA555AA5\x07\x0b\x0e.\x0b\x0b.\x0b\x00\x00\x00\x00\x00..\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\nAAAAAA\x0c\x0b\t-\x0b\x0b\x0b\x0b\x0b...\x00\x00\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0bAAAA5\x0b0/\x0b\x0b\x0b\x0b\x0b\x0b...',
        },
        catEyes: {
          open: 'â€¢',
          closed: '-',
          poked: '0',
        },
      };

      const state = {
        grid: {
          chars: [],
          numRows: 0,
          numColumns: 0,
          frame: 0,
          nextFrameTime: 0,
        },
        cat: {
          areEyesOpen: false,
          lastPokeCatTime: 0,
          nextFrameTime: 0,
        },
        mouse: {
          x: 0,
          y: 0,
          prevX: 0,
          prevY: 0,
          velocityX: 0,
          velocityY: 0,
          seen: false,
        },
        click: {
          x: 0,
          y: 0,
          lastClickTime: 0,
        },
      };

      // Decode a pixel image into a 2D array of hex strings
      // `colors` is an array of hex colors, and `image` is a string of characters whose ASCII values map to the colors
      // `columns` is the number of columns in the image
      const decodeImage = ({columns, colors, image}) => {
        const decoded = image.split('').map(c => colors[c.charCodeAt(0)]);
        const pixels = [];
        for (let i = 0; i < decoded.length; i += columns) {
          pixels.push(decoded.slice(i, i + columns));
        }
        return pixels;
      }

      // Convert pixels (a 2D array of hex strings) into an array of characters with formatting tags
      const getCharsFromImage = (pixels) => {
        const chars = [];
        for (let y = 0; y < pixels.length - 1; y += 4) {
          for (let x = 0; x < pixels[y].length; x += 2) {
            const colors = [
              pixels[y][x], pixels[y][x+1], pixels[y+1][x], pixels[y+1][x+1], pixels[y+2][x], pixels[y+2][x+1], pixels[y+3][x], pixels[y+3][x+1]
            ]
            chars.push({
              id: `pixels-${y}-${x}`,
              char: ' ',
              tags: [{name: 'pixels', args: colors.map(c => c === "#ffffff" ? config.backgroundColor : c)}]
            });
          }
          chars.push({
            id: `pixels-${y}-newline`,
            char: '\n',
            tags: []
          });
        }
        return chars;
      }

      // Convert a string into an array of characters with formatting tags
      const getCharsFromText = (text) => {
        const chars = [];
        const activeTags = [];
        const codePoints = [...text]; // Split by unicode code points

        for (let i = 0; i < codePoints.length; i++) {
          if (codePoints[i] === '[' && codePoints.includes(']', i)) {
            const j = codePoints.indexOf(']', i);
            const tag = codePoints.slice(i + 1, j).join('');
            if (tag[0] === '/') {
              // Closing tag: [/tag]
              const tagName = tag.slice(1);
              const index = activeTags.findIndex(t => t.name === tagName);
              if (index !== -1) activeTags.splice(index, 1);
            } else {
              // Opening tag: [tag arg1 arg2]
              const [name, ...args] = tag.split(/\s+/);
              activeTags.push({name, args});
            }
            i = j;
            continue;
          }

          // Regular character
          chars.push({
            id: `text-${i}`,
            char: codePoints[i],
            tags: [...activeTags]
          });
        }
        return chars;
      }

      // Wrap text into lines of maximum width
      const wrapText = (chars, width) => {
        const lines = [];
        let line = [];

        for (const char of chars) {
          if (char.char === '\n') {
            lines.push(line);
            line = [];
            continue;
          }
          line.push(char);

          if (line.length > width) {
            const i = line.findLastIndex(char => char.char === ' ');
            if (i >= 0) {
              lines.push(line.slice(0, i));
              line = line.slice(i + 1);
            } else {
              lines.push(line);
              line = [];
            }
          }
        }

        if (line.length) lines.push(line);
        return lines;
      };

      const generateChars = () => {
        // Calculate number of columns and min rows based on window size
        // Subtract 2 so that the horizontal scrollbar doesn't show up
        const minRows = Math.floor(window.innerHeight / config.charHeight);
        const numColumns = Math.floor(window.innerWidth / config.charWidth) - 2;

        // Parse the website text and wrap it into lines
        let chars = [
          ...getCharsFromImage(decodeImage(config.pfpImage)),
          ...getCharsFromText(config.content),
        ];

        // Calculate number of columns to wrap text into
        // It's between 60% and 80% depending on the window width
        const sizeWeight = Math.min(1, Math.max(0, (window.innerWidth - 600) / 1000));
        const numWrapColumns = Math.ceil(numColumns * (0.6 * sizeWeight + 0.8 * (1 - sizeWeight)));

        // Wrap the text into lines and attach final positions
        const lines = wrapText(chars, numWrapColumns);
        const numRows = Math.max(minRows, lines.length + 8);
        const startY = Math.max(5, Math.floor((numRows - lines.length) * 0.4));
        const startX = Math.floor((numColumns - numWrapColumns) * 0.5);
        for (let y = 0; y < lines.length; y++) {
          for (let x = 0; x < lines[y].length; x++) {
            const char = lines[y][x];
            char.finalY = y + startY;
            char.finalX = x + startX;
          }
        }

        // Remove chars not assigned a final position, such as spaces that were wrapped
        chars = chars.filter(c => c.finalX !== undefined && c.finalY !== undefined);

        // Remove whitespace chars
        chars = chars.filter(c => (c.char !== ' ' && c.char !== '\n') || c.tags.length > 0);

        // Set initial positions and weights
        for (const char of chars) {
          char.y = sample.uniformInt(0, numRows);
          char.x = sample.uniformInt(0, numColumns);
          char.weight = sample.uniform(0, 1);
        }

        return {chars, numRows, numColumns};
      }

      const createCharElement = (char) => {
        const {charWidth, charHeight} = config;
        const el = document.createElement('a');
        el.style.position = 'absolute';
        el.style.top = `${char.y * charHeight}px`;
        el.style.left = `${char.x * charWidth}px`;
        el.style.minWidth = `${charWidth}px`;
        el.style.minHeight = `${charHeight}px`;
        el.textContent = char.char;
        el.id = `char-${char.id}`;

        for (const {name, args} of char.tags) {
          if (name === 'link') {
            el.href = args[0];
          } else if (name === 'b') {
            el.style.fontWeight = 'bold';
          } else if (name === 'i') {
            el.style.fontStyle = 'italic';
          } else if (name === 'eye') {
            el.classList.add('eye');
          } else if (name === 'pixels') {
            el.classList.add('pixels');
            args.forEach(color => {
              const colorElement = document.createElement('a');
              colorElement.style.background = color;
              el.appendChild(colorElement);
            });
          }
        }
        return el;
      }

      // Add invisible span in the bottom right corner so the container size is fixed
      const createCornerElement = () => {
        const {charWidth, charHeight} = config;
        const {numRows, numColumns} = state.grid;
        const corner = document.createElement('a');
        corner.style.position = 'absolute';
        corner.style.top = `${(numRows-1) * charHeight}px`;
        corner.style.left = `${(numColumns-1) * charWidth}px`;
        corner.textContent = ' ';
        return corner;
      }

      const animateGrid = (t) => {
        const {grid} = state;
        if (t > grid.nextFrameTime) {
          updateMouseVelocity();
          evolveChars();
          grid.chars.forEach(updateCharElementPosition);
          grid.nextFrameTime = t + config.intervalMs;
          grid.frame++;
        }
        requestAnimationFrame(animateGrid);
      }

      const updateMouseVelocity = () => {
        state.mouse.velocityX *= 0.9;
        state.mouse.velocityY *= 0.9;
        state.mouse.velocityX += state.mouse.x - state.mouse.prevX;
        state.mouse.velocityY += state.mouse.y - state.mouse.prevY;
        state.mouse.prevX = state.mouse.x;
        state.mouse.prevY = state.mouse.y;
      }

      const evolveChars = () => {
        const {frame, chars, numRows, numColumns} = state.grid;
        const {charWidth, charHeight, maxFrame} = config;
        const {mouse} = state;
        const t = Math.min(frame / maxFrame, 1);
        const isAfterFinalFrame = frame >= maxFrame;

        // Map to look up chars by their position
        const positionMap = {};
        chars.forEach(char => {
          const key = `${char.y},${char.x}`;
          positionMap[key] = char;
        });

        // Indices of positions that have already moved
        const frozenPositions = new Set();

        const moveChar = (char, {x, y}) => {
          positionMap[`${char.y},${char.x}`] = null;
          positionMap[`${y},${x}`] = char;
          frozenPositions.add(`${y},${x}`);
          char.y = y;
          char.x = x;

          if (isAfterFinalFrame && char.tags.some(tag => tag.name === 'eye')) {
            setCatEyes(config.catEyes.poked);
            state.cat.lastPokeCatTime = t;
          }
        }

        // Sort so we process characters furthest from their target first
        // This reduces probability of characters getting stuck and not reaching their final position
        const sortedChars = [...chars].sort((a, b) => {
          const distA = Math.abs(a.finalY - a.y) + Math.abs(a.finalX - a.x);
          const distB = Math.abs(b.finalY - b.y) + Math.abs(b.finalX - b.x);

          // Add a bit of randomness to help not get stuck
          return distB - distA + sample.uniform(-3, 3);
        });

        // Freeze links when mouse is nearby so it's easier to click on them. A bit hacky but works.
        let minLinkDistance = Infinity;
        for (const char of sortedChars) {
          const mouseVector = {
            x: state.mouse.x / charWidth - char.x,
            y: state.mouse.y / charHeight - char.y,
          }
          const mouseDist = Math.hypot(mouseVector.x, mouseVector.y);
          const isLink = char.tags.some(tag => tag.name === 'link');
          if (isAfterFinalFrame && isLink && char.finalY === char.y && char.finalX === char.x && mouseDist < 0.05 * numColumns) {
            frozenPositions.add(`${char.y},${char.x}`);
            minLinkDistance = Math.min(minLinkDistance, mouseDist);
          }
        }

        for (const char of sortedChars) {
          // If the character is frozen, don't move it
          if (frozenPositions.has(`${char.y},${char.x}`)) {
            continue;
          }

          // How much we want to move the character. We'll adjust this value throughout this function.
          const moveVector = {x: 0, y: 0};

          // Pull towards final position. Starts at time 0.25 - 0.75 depending on weight and ends at time 1
          {
            const w = Math.max(0, (t - 0.75 + char.weight * 0.5) / 0.75);
            moveVector.x += w * (char.finalX - char.x);
            moveVector.y += w * (char.finalY - char.y);
          }

          // Curl clockwise around viewport center
          const centerVector = {
            x: (window.scrollX + window.innerWidth / 2) / charWidth - char.x + 0.1 * sample.gaussian(),
            y: (window.scrollY + window.innerHeight / 2) / charHeight - char.y + 0.1 * sample.gaussian(),
          };
          const centerDistance = Math.hypot(centerVector.x, centerVector.y);
          if (centerDistance > 0) {
            const w = Math.max(0, 0.8 - t) / 0.8;
            moveVector.x += w * centerVector.y / centerDistance;
            moveVector.y += w * -centerVector.x / centerDistance;
          }

          // Pull towards mouse position. Don't do this on mobile.
          const mouseVector = {
            x: state.mouse.x / charWidth - char.x,
            y: state.mouse.y / charHeight - char.y,
          }
          const mouseDistance = Math.hypot(mouseVector.x, mouseVector.y);
          if (mouse.seen && mouseDistance / 6 < (1 - char.weight) * Math.min(1, minLinkDistance / 0.02 / numColumns)) {
            const mouseSpeed = Math.hypot(mouse.velocityX / charWidth, mouse.velocityY / charHeight);
            const w = (1 - char.weight) * Math.min(1, mouseSpeed / 100);
            moveVector.x += 1 * w * mouseVector.x / mouseDistance;
            moveVector.y += 1 * w * mouseVector.y / mouseDistance;
            moveVector.x += 300 * w * mouse.velocityX / mouseSpeed;
            moveVector.y += 300 * w * mouse.velocityY / mouseSpeed;
          }

          // If clicked recently, do an explosion effect
          const timeSinceLastClick = Date.now() - state.click.lastClickTime;
          if (timeSinceLastClick < 3000 * (1 - char.weight)) {
            const clickVector = {
              x: state.click.x / charWidth - char.x,
              y: state.click.y / charHeight - char.y,
            }
            const clickDistance = Math.hypot(clickVector.x, clickVector.y);
            const w = Math.pow(Math.max(0, 1 - clickDistance / 50), 2);

            // Curl counter-clockwise around click position
            moveVector.x += -100 * w * clickVector.y / clickDistance;
            moveVector.y += 100 * w * clickVector.x / clickDistance;

            // Push away from click position
            moveVector.x += -20 * w * clickVector.x / clickDistance;
            moveVector.y += -20 * w * clickVector.y / clickDistance;
          }

          // If the character is not moving, freeze it
          if (Math.hypot(moveVector.x, moveVector.y) < 0.001) {
            frozenPositions.add(`${char.y},${char.x}`);
            continue;
          }

          // Move character one step in the direction of the force, adding a bit of randomness
          const theta = Math.atan2(moveVector.y, moveVector.x) + sample.uniform(-Math.PI / 4, Math.PI / 4);
          const angleStep = Math.PI / 4;
          const discretizedTheta = Math.round(theta / angleStep) * angleStep;

          // Calculate direction of movement based on theta
          const newPosition = {
            x: (char.x + Math.round(Math.cos(discretizedTheta)) + numColumns) % numColumns,
            y: (char.y + Math.round(Math.sin(discretizedTheta)) + numRows) % numRows,
          }

          // If there is a character and it has already moved, don't move this character
          const key = `${newPosition.y},${newPosition.x}`;
          if (frozenPositions.has(key)) {
            continue;
          }

          // Check to see if there's already a character in the position we want to move to
          // Swap positions with target character if it exists
          const targetChar = positionMap[key];
          if (targetChar) {
            moveChar(targetChar, char);
          }
          moveChar(char, newPosition);
        }
      };

      const updateCharElementPosition = ({x, y, id}) => {
        const span = document.getElementById(`char-${id}`);
        span.style.top = `${y * config.charHeight}px`;
        span.style.left = `${x * config.charWidth}px`;
      }

      // Make the cat's eyes blink
      const animateCat = t => {
        const {cat} = state;
        const {open, closed} = config.catEyes;
        if (t > cat.nextFrameTime + config.intervalMs && t > cat.lastPokeCatTime + 1500) {
          cat.areEyesOpen = !cat.areEyesOpen;

          // Update all eye elements
          setCatEyes(cat.areEyesOpen ? open : closed);

          // Wait a random log-normally distributed length of time
          // Eyes stay open longer than they stay closed
          const multiplier = cat.areEyesOpen ? 2 : 0.15;
          const wait = Math.exp(0.7 * sample.gaussian()) * multiplier * 1000;
          cat.nextFrameTime = t + wait;
        }
        requestAnimationFrame(animateCat);
      }

      const setCatEyes = eye => {
        const spans = document.querySelectorAll('.eye');
        spans.forEach(span => {
          span.textContent = eye;
        });
      }

      const sample = {
        uniform: (min, max) => min + Math.random() * (max - min),
        uniformInt: (min, max) => Math.floor(sample.uniform(min, max + 1)),
        exponential: lambda => -Math.log(Math.random()) / lambda,
        gaussian: () => {
          const r = Math.sqrt(sample.exponential(2));
          const theta = 2 * Math.PI * Math.random();
          return r * Math.cos(theta);
        },
      }

      const startDance = () => {
        document.body.style.background = config.backgroundColor;
        document.addEventListener('mousemove', (e) => {
          state.mouse.x = e.pageX;
          state.mouse.y = e.pageY;
          state.mouse.seen = true;
        });
        document.addEventListener('click', function(event) {
          if (!event.target.closest('a')) {
            state.click.x = event.clientX;
            state.click.y = event.clientY;
            state.click.lastClickTime = Date.now();
          }
        });

        // Generate characters and update state
        const {chars, numRows, numColumns} = generateChars();
        state.grid.numRows = numRows;
        state.grid.numColumns = numColumns;
        state.grid.chars = chars;

        // Create DOM elements
        const container = document.getElementById('container');
        const elements = [...chars.map(createCharElement), createCornerElement()];
        elements.forEach(el => container.appendChild(el));

        // Start animations
        requestAnimationFrame(animateGrid);
        requestAnimationFrame(animateCat);
      };

      startDance();
    });
  </script>
</body>
</html>