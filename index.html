<!DOCTYPE html>
<html>
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
      <title>takaki oshima's personal homepage</title>
      <style>
            html, body {
                  height: 100%;
                  margin: 0;
                  padding: 0;
            }
            body {
                  font-family: 'Source Code Pro', monospace;
                  font-size: 15px;
                  background: #f9f9f9;
                  color: #222222;
            }
            #container {
                  margin: 0;
                  padding: 0;
                  min-height: 100vh;
                  overflow: auto;
                  line-height: 1.3;
                  letter-spacing: 0;
                  white-space: pre;
            }
      </style>
</head>
<body>
      <div id="container"></div>
      <script>
            const dance = () => {
                  // Update this if font size or font family changes
                  // I couldn't find a reliable way to calculate these on-the-fly
                  const CHAR_WIDTH = 15 * 0.6;
                  const CHAR_HEIGHT = 15 * 1.3;

                  // Settings
                  const MARGIN_TOP = 0.03; // Margin at top of page
                  const MARGIN_BOTTOM = 0.02; // Margin at bottom of page
                  const MARGIN_SIDE = 0.1; // Margin on each side of page
                  const NUM_STEPS = 200; // Number of steps in the animation. Determines how long the animation lasts.
                  const INTERVAL_MS = 60; // Interval between steps in the animation. Determines how fast the characters move.

                  // These tokens below are just random emojis that can be put in the text content and will replaced
                  // by the characters in `currentCatFace` at render time.
                  const CAT_TOKENS = ["⚈", "⚆", "⚉"];
                  const CAT_FACES = ["•^•", "•^•", "0^0", "0^0", "-^-", "-^-", "-^•", "•^-"]; // ["'^'", "o^o"]
                  let currentCatFace = CAT_FACES[Math.floor(Math.random() * CAT_FACES.length)];

                  // Warning for small displays
                  const SMALL_DISPLAY_WARNING = "[b]it looks like you're on mobile or have a small display. fyi the animation looks best on a computer with a larger display[/b]";

                  // Website content
                  const CONTENT = [
                        "welcome to the personal homepage of [b]takaki oshima[/b]",
                        ...(window.innerWidth < 1000 ? [SMALL_DISPLAY_WARNING] : []),
                        `
                              work
                              ~~~~
                              my main work is as an independent researcher. my interests span a bunch of domains including
                                - ai
                                - automated market making protocols
                                - quantitative sports betting
                                - creative coding

                              in the past i worked as a swe at [google](https://google.com/) and as an hft quant. i later cofounded a startup where i researched and designed decentralized protocols.
                        `,
                        `
                              books
                              ~~~~~
                              below are my favourite books or books which have influenced me in some way. in no particular order.
                                - what i talk about when i talk about running by haruki murakami (this book got me into running)
                                - folding beijing by hao jingfang
                                - siddhartha by hermann hesse
                                - the three body problem series by liu cixin
                                - the almanack of naval ravikant by eric jorgenson
                                - sapiens by yuval noah harari
                                - the dispossessed by ursula k. le guin
                                - why we sleep by matthew walker (this book scared me into trying to sleep better)
                                - the life-changing magic of tidying up by marie kondo (this book made me more into a minimalist)
                        `,
                        `
                              tea
                              ~~~
                              i like tea, especially peppermint and ali shan.
                        `,
                        `
                              about this website
                              ~~~~~~~~~~~~~~~~~~
                              i'd been meaning to make a personal website for a while but never got round to it because i didn't really have a need for one. i still don't have a need for one but i did have an idea (text dancing around then settling into place) and also had an itch to create something, so i made this in february 2025.

                              if you refresh the page, it'll be different every time. the character positions and the layout of the text are randomly generated on the fly.

                              this site is best viewed on a large display. it uses my favourite coding font, [source code pro](https://adobe-fonts.github.io/source-code-pro/).

                              it takes inspiration from the work of generative artists like [andreas gysin](https://ertdfgcvb.xyz/) and more generally from the field of creative coding such as [kim asendorf](https://kimasendorf.com/)'s [pixel sorting algorithm](https://github.com/kimasendorf/ASDFPixelSort).
                        `,
                        `
                              about the animation
                              ~~~~~~~~~~~~~~~~~~~
                              each character has a random velocity and mass and i take 2x2 groups of characters and rotate them clockwise or counterclockwise depending on their combined angular momentum. so each frame, every character moves exactly one step - characters aren't allowed to teleport or stay still (until they reach their final position). these steps are deterministic so can be run backwards to figure out where the characters should start in order to end up in the right positions.
                        `,
                        `
                              source code
                              ~~~~~~~~~~~
                              the source code for this website can be found on [github](https://github.com/toshima/homepage).

                              it's contained in a single ~500 line html file and it should be pretty readable. but i'm not a js main so it's not really written in an idiomatic way.
                        `,
                        `
                              ai seems to be getting really good really quickly. my framework rn is to:
                                1. use ai for the things it can do (eg tools like cursor)
                                2. use my time doing things it can't do yet (eg building a business)
                        `,
                        `
                               /\\_/\\
                              ( ⚈.⚉ )
                               " ⚆ "
                        `,
                        `
                              "a journey of a thousand miles begins with a single step" - lao tzu
                        `,
                        `
                              socials
                              ~~~~~~~
                              i don't use social media much but i have accounts on [github](https://github.com/toshima/) and (less actively) on [twitter](https://x.com/takakioshima/) and [linkedin](https://www.linkedin.com/in/takakioshima/).
                        `,
                        `
                              last updated in february 2025
                        `,
                  ];

                  // Remove leading whitespace from each line
                  function dedent(text) {
                        const lines = text.split('\n');
                        const indentLength = Math.min(...lines.filter(line => line.trim()).map(line => line.match(/^ */)[0].length));
                        return lines.map(line => line.slice(indentLength)).join('\n');
                  }

                  // Take in a string and return an array of characters together with their formatting.
                  // For example, "[b]h[/b]i" -> [{char: "h", link: null, bold: true}, {char: "i", link: null, bold: false}]
                  function parseFormattedCharacters(input) {
                        const chars = [...input]; // This splits correctly for multi-byte characters like emojis
                        const result = [];
                        let i = 0;
                        while (i < chars.length) {
                              if (chars[i] === '[') {
                                    if (chars.slice(i, i + 3).join('') === '[b]') {
                                          const j = chars.indexOf('[', i + 3);
                                          if (j !== -1 && chars.slice(j, j + 4).join('') === '[/b]') {
                                                const boldText = chars.slice(i + 3, j);
                                                for (const char of boldText) {
                                                      result.push({char, link: null, bold: true});
                                                }
                                                i = j + 4; // Skip past "[/b]"
                                                continue;
                                          }
                                    }
                                    const j = chars.indexOf(']', i + 1);
                                    const k = chars.indexOf(')', i + 1);
                                    if (j !== -1 && k !== -1 && chars[j+1] === "(") {
                                          const linkText = chars.slice(i + 1, j).join('');
                                          const linkUrl = chars.slice(j + 2, k).join('');
                                          for (const char of linkText) {
                                                result.push({char, link: linkUrl, bold: false});
                                          }
                                          i = k + 1; // Skip past ")"
                                          continue;
                                    }
                              }
                              result.push({char: chars[i], link: null, bold: false});
                              i++;
                        }
                        return result;
                  }

                  // Take in an array of formatted characters and return an array of lines,
                  // splitting when the text is too long
                  const wrapText = (formattedChars, width) => {
                        const lines = [];
                        let line = [];
                        let lastSpaceIdx = -1;
                        for (const fc of formattedChars) {
                              if (fc.char === '\n') {
                                    lines.push(line);
                                    line = [];
                                    lastSpaceIdx = -1;
                                    continue;
                              }
                              line.push(fc);
                              if (fc.char === ' ') {
                                    lastSpaceIdx = line.length - 1;
                              }
                              if (line.length >= width) {
                                    if (lastSpaceIdx >= 0) {
                                          lines.push(line.slice(0, lastSpaceIdx));
                                          line = line.slice(lastSpaceIdx + 1);
                                    } else {
                                          lines.push(line);
                                          line = [];
                                          lastSpaceIdx = -1;
                                    }
                              }
                        }
                        if (line.length) {
                              lines.push(line);
                        }
                        return lines;
                  };

                  const updateTextBlockPositions = (rectangles, numColumns) => {
                        // Calculate the margins in terms of the number of columns
                        const ms = Math.max(1, Math.floor(MARGIN_SIDE * numColumns));
                        const mt = Math.max(1, Math.floor(MARGIN_TOP * numColumns));

                        for (const [i, rectangle] of rectangles.entries()) {
                              const {width, height} = rectangle;
                              for (let row = mt; row < mt + 10_000; row += 1) {
                                    const column = sampleUniformInt(ms, numColumns - width - ms);
                                    if (!rectangles.slice(0, i).some(r => 
                                          column < r.column + r.width + 2 && 
                                          column + width > r.column - 2 &&
                                          row < r.row + r.height + 2 && 
                                          row + height > r.row - 2
                                    )) {
                                          rectangle.row = row;
                                          rectangle.column = column;
                                          break;
                                    }
                              }
                        }
                  }

                  // Get the width of a monospace character in pixels
                  // const getMonospaceWidth = (fontSize, fontFamily) => {
                  //       const canvas = document.createElement('canvas');
                  //       const context = canvas.getContext('2d');
                  //       context.font = `${fontSize}px "${fontFamily}"`;
                  //       const metrics = context.measureText('M');
                  //       return metrics.width;
                  // }

                  const generateCells = (numRows, numColumns) => {
                        const cells = [];
                        for (let r = 0; r < numRows; r++) {
                              for (let c = 0; c < numColumns; c++) {
                                    cells.push({
                                          initialRow: r,
                                          initialColumn: c,
                                          formattedChar: {char: ' ', link: null, bold: false},
                                          mass: sampleExponential(1),
                                          rowVelocity: sampleGaussian(),
                                          columnVelocity: sampleGaussian(),
                                          stopStep: sampleUniformInt(0.7 * NUM_STEPS, NUM_STEPS),
                                          row: r,
                                          column: c,
                                    });
                              }
                        }
                        return cells;
                  }

                  const simulateAndPopulateCellChars = (cells, numRows, numColumns, textBlocks) => {
                        // Create a copy of the cells so we don't actually move the original cells
                        const simulationState = {
                              cells: cells.map(cell => ({...cell})),
                              numRows,
                              numColumns,
                              step: 0,
                        }

                        // Simulate all the steps without displaying anything
                        for (let i = 0; i < NUM_STEPS; i++) {
                              evolve(simulationState);
                              simulationState.step += 1;
                        }

                        // Create mapping to speed things up
                        const simulatedCellMap = createCellMap(simulationState.cells);
                        const cellMap = createCellMap(cells);

                        // Populate the cells with the characters from the simulation
                        for (const block of textBlocks) {
                              for (const [r, line] of block.lines.entries()) {
                                    for (const [c, formattedChar] of line.entries()) {
                                          // Find the cell that ended up in this position in the simulation
                                          const simCell = simulatedCellMap[`${block.row + r},${block.column + c}`];
                                          if (simCell) {
                                                // Update the cell in the simulated cell's initial position
                                                const cell = cellMap[`${simCell.initialRow},${simCell.initialColumn}`];
                                                cell.formattedChar = formattedChar;
                                          }
                                    }
                              }
                        }
                  }

                  // Update the container with multiple lines of random text
                  const update = (state) => {
                        evolve(state);
                        display(state);
                        state.step += 1;

                        // Change the cat face at random intervals
                        if (Math.random() < 0.5 && state.step % 50 === 0) {
                              currentCatFace = CAT_FACES[Math.floor(Math.random() * CAT_FACES.length)];
                        }

                        // We keep running after NUM_STEPS has elapsed so the cat face can keep changing
                        // But after 10 * NUM_STEPS, we stop running
                        if (state.step >= 10 * NUM_STEPS) {
                              clearInterval(intervalId);
                              return;
                        }
                  }

                  // Update the webpage with the current state of the simulation
                  const display = ({cells, step}) => {
                        let lines = [];
                        for (let r = 0; r < numRows; r++) {
                              const rowCells = cells.filter(cell => cell.row === r).sort((a, b) => a.column - b.column);
                              lines.push(rowCells.map(({formattedChar: {char, link, bold}, stopStep}) => {
                                    if (bold) {
                                          return `<strong>${char}</strong>`;
                                    } else if (link && step >= stopStep) {
                                          // Only show links after they're in their final position
                                          return `<a href="${link}" style="color: inherit; text-decoration: underline;">${char}</a>`;
                                    } else if (CAT_TOKENS.includes(char)) {
                                          // Replace the token with the corresponding one in the current cat face
                                          return currentCatFace[CAT_TOKENS.indexOf(char)];
                                    } else {
                                          return char;
                                    }
                              }).join(''));
                        }
                        const container = document.getElementById('container');
                        container.innerHTML = lines.join('\n');
                  }

                  // Update the simulation state by one step
                  const evolve = (state) => {
                        const {cells, numRows, numColumns, step} = state;
                        const cellMap = createCellMap(cells);

                        // We look at tilings of 2x2 squares of cells, alternating between starting at (0, 0) and (1, 1)
                        for (let r = step % 2; r < numRows-1; r += 2) {
                              for (let c = step % 2; c < numColumns-1; c += 2) {
                                    const group = [
                                          cellMap[`${r},${c}`],
                                          cellMap[`${r},${(c + 1)}`],
                                          cellMap[`${(r + 1)},${(c + 1)}`],
                                          cellMap[`${(r + 1)},${c}`],
                                    ];
                                    if (group.some(({stopStep}) => step >= stopStep)) {
                                          continue;
                                    }

                                    const clockwise = calculateAngularMomentum(group) < 0;
                                    if (clockwise) {
                                          group[0].row += 1;
                                          group[1].column -= 1;
                                          group[2].row -= 1;
                                          group[3].column += 1;
                                    } else {
                                          group[0].column += 1;
                                          group[1].row += 1;
                                          group[2].column -= 1;
                                          group[3].row -= 1;
                                    }
                              }
                        }
                  }

                  const calculateAngularMomentum = (group) => {
                        const centerRow = group.reduce((sum, cell) => sum + cell.row, 0) / group.length;
                        const centerColumn = group.reduce((sum, cell) => sum + cell.column, 0) / group.length;
                        let angularMomentum = 0;
                        for (const cell of group) {
                              const dr = cell.row - centerRow;
                              const dc = cell.column - centerColumn;
                              angularMomentum += cell.mass * (dr * cell.columnVelocity - dc * cell.rowVelocity);
                        }
                        return angularMomentum;
                  }

                  // Create a map to look up cells by their row and column for efficient lookup
                  const createCellMap = (cells) => {
                        const cellMap = {};
                        cells.forEach(cell => {
                              cellMap[`${cell.row},${cell.column}`] = cell;
                        });
                        return cellMap;
                  }

                  // Sample a background color close to white
                  const sampleBackgroundColor = () => {
                        const r = sampleUniformInt(245, 255);
                        const g = sampleUniformInt(245, 255);
                        const b = sampleUniformInt(245, 250); // Want less blue than red or green
                        return `rgb(${r}, ${g}, ${b})`;
                  }

                  const sampleUniform = (min, max) => {
                        return min + Math.random() * (max - min);
                  }

                  const sampleUniformInt = (min, max) => {
                        return Math.floor(sampleUniform(min, max + 1));
                  }

                  const sampleExponential = (lambda) => {
                        return -Math.log(Math.random()) / lambda;
                  }

                  const sampleGaussian = () => {
                        const r = Math.sqrt(sampleExponential(2));
                        const theta = 2 * Math.PI * Math.random();
                        return r * Math.cos(theta);
                  }

                  // Sample and set a random background color
                  document.body.style.backgroundColor = sampleBackgroundColor();

                  // Calculate number of columns and min rows based on window size.
                  // Subtract 1 so we don't see scrollbars.
                  const numColumns = Math.floor(window.innerWidth / CHAR_WIDTH) - 1;
                  const minRows = Math.floor(window.innerHeight / CHAR_HEIGHT) - 1;

                  // Parse the website text and wrap it into lines
                  const textBlocks = CONTENT.map(string => {
                        const text = parseFormattedCharacters(dedent(string));
                        const minWidth = string.length > 100 ? 30 : 20;
                        const maxWidth = Math.min(numColumns * (1 - 2 * MARGIN_SIDE), 60);
                        const width = sampleUniformInt(minWidth, maxWidth);
                        const lines = wrapText(text, width);
                        return {
                              lines,
                              width,
                              height: lines.length,
                        }
                  });
                  updateTextBlockPositions(textBlocks, numColumns);

                  // Calculate the number of rows based on the block positions
                  const numRows = Math.max(minRows, Math.max(...textBlocks.map(block => block.row + block.height)) + Math.floor(MARGIN_BOTTOM * numColumns));

                  // Generate the cells and simulate the movement of the characters
                  const cells = generateCells(numRows, numColumns);
                  simulateAndPopulateCellChars(cells, numRows, numColumns, textBlocks);

                  // Run and display the simulation
                  const state = {cells, numRows, numColumns, step: 0};
                  const intervalId = setInterval(() => update(state), INTERVAL_MS);
                  display(state);
            }

            document.fonts.ready.then(() => {
                  dance();
            });
      </script>
</body>
</html>
