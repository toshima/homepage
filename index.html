<!--
TODO:
- Refactor - have a single CONFIG object and state object
-->

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Takaki Oshima's homepage">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <title>Takaki Oshima's homepage</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Source Code Pro', monospace;
      font-size: 15px;
      color: #222222;
    }
    #container {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow: auto;
      line-height: 1.35;
      letter-spacing: 0;
      white-space: pre;
    }
    #container a {
      color: inherit; /* Don't colorize links */
    }
    .pixels {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(4, 1fr);
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    const dance = () => {
      // Update these if font size or font family changes.
      // Couldn't find a reliable way to calculate them on-the-fly.
      const FONT_SIZE = 15;
      const CHAR_WIDTH = FONT_SIZE * 0.6;
      const CHAR_HEIGHT = FONT_SIZE * 1.35;

      // Settings
      const BACKGROUND_COLOR = "#ffebf4";
      const SPACING = 3; // Minimum number of spaces between text blocks
      const MARGIN_TOP = 0.03; // Margin at top of page
      const MARGIN_BOTTOM = 0.02; // Margin at bottom of page
      const MARGIN_SIDE = 0.05; // Margin on each side of page
      const NUM_STEPS = 200; // Number of steps in the animation. Determines how long the animation lasts.
      const INTERVAL_MS = 15; // Interval between steps in the animation. Determines how fast the characters move.
      const EVOLVE_FRAMES = 400;

      const PFP_IMAGE = [
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#9c9c9c", "#000000", "#000000", "#000000", "#000000", "#adbadd", "#adbadd", "#000000", "#000000", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#424755", "#adbadd", "#adbadd", "#adbadd", "#adbadd", "#3f4c77", "#3f4c77", "#3f4c77", "#adbadd", "#adbadd", "#000000", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#b1bee2", "#828fb5", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#42507d", "#0a0a0a", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#404d79", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3c4872", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4d78", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#adbadd", "#adbadd", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3c4872", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4d78", "#3f4c77", "#3f4c77", "#3f4c77", "#3e4b76", "#adbadd", "#adbadd", "#adbadd", "#adbadd", "#adbadd", "#adbadd", "#404d78", "#3f4c77", "#3f4c77", "#3c4872", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4d78", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#adbadd", "#adbadd", "#adbadd", "#adbadd", "#adbadd", "#404d78", "#3f4c77", "#384571", "#a5b2d3", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#3f4c77", "#3f4c77", "#3f4c77", "#3d4a74", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#020302", "#43507b", "#adbadd", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#3f4c77", "#3f4c77", "#28314c", "#060709", "#050608", "#1a1c20", "#4e4644", "#1a1c20", "#090a0b", "#090a0b", "#090a0b", "#090a0b", "#090a0b", "#090a0b", "#08090d", "#3f4c77", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#3f4c77", "#3f4c77", "#28314c", "#060709", "#37221d", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#060709", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#3f4c77", "#36211a", "#37221d", "#3a251f", "#dbc0b7", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#34201c", "#060709", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#3f4c77", "#36211a", "#765e58", "#d8bdb4", "#9e847b", "#453836", "#5a4b47", "#9e847b", "#947167", "#947167", "#604c47", "#453836", "#5c4d49", "#5c4d49", "#34201c", "#060709", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#36211b", "#ddc2b9", "#dabfb6", "#dabfb6", "#dabfb6", "#9e847b", "#9e847b", "#9e847b", "#dfc9c2", "#dfc9c2", "#9e847b", "#604c47", "#a58b81", "#9e847b", "#997f77", "#37221d", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#36211b", "#ddc2b9", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#9e847b", "#9e847b", "#dfc9c2", "#dfc9c2", "#9e847b", "#9e847b", "#9e847b", "#9a8077", "#d3b8af", "#37221d", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#3f4c77", "#36211b", "#ddc2b9", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#dfc9c2", "#dfc9c2", "#dabfb6", "#9e847b", "#e1c6bd", "#dabfb6", "#d3b8af", "#37221d", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#535e72", "#1f232c", "#37221c", "#ddc2b9", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#dfc9c2", "#dfc9c2", "#dfc9c2", "#dfc9c2", "#dabfb6", "#dabfb6", "#e3c8be", "#34201b", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#535e72", "#535e72", "#1f232c", "#1f232c", "#35211c", "#765e58", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#947167", "#947167", "#947167", "#947167", "#d9beb5", "#dabfb6", "#e3c8be", "#34201b", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#535e72", "#535e72", "#1f232c", "#1f232c", "#35211c", "#765e58", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#dabfb6", "#9e847b", "#604c47", "#9e847b", "#d9beb5", "#dabfb6", "#e3c8be", "#382420", "#535e72", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#000000", "#535e72", "#535e72", "#1f232c", "#1f232c", "#35211c", "#765e58", "#dabfb6", "#dabfb6", "#dabfb6", "#9e847b", "#9e847b", "#a57c76", "#a57975", "#9e847b", "#9e847b", "#e1c6bd", "#e3c8be", "#36221d", "#1f232c", "#535e72", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#000000", "#000000", "#000000", "#535e72", "#535e72", "#535e72", "#1f232c", "#1f232c", "#a0867c", "#765e56", "#3a251f", "#dbc0b7", "#604c47", "#774a49", "#774a49", "#ac676e", "#ac676e", "#774a49", "#604b47", "#311c17", "#38211c", "#21252e", "#535e72", "#535e72", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#000000", "#535e72", "#535e72", "#535e72", "#1f232c", "#535e72", "#1f232c", "#1f232c", "#a0867c", "#9e847b", "#9c8279", "#36211c", "#9e847b", "#9e847b", "#9e847b", "#604c47", "#604c47", "#9e847b", "#9e847b", "#2a1511", "#38211c", "#21252e", "#535e72", "#535e72", "#535e72", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#000000", "#535e72", "#535e72", "#535e72", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#50484a", "#9c8279", "#36211c", "#9e847b", "#dabfb6", "#dabfb6", "#9e847b", "#9e847b", "#dabfb6", "#38231e", "#65514c", "#634e48", "#21252e", "#535e72", "#535e72", "#535e72", "#000000", "#ffffff", "#ffffff", "#ffffff", "#ffffff"],
        ["#ffffff", "#ffffff", "#000000", "#535e72", "#535e72", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#50484a", "#9e847b", "#9e847b", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#37221d", "#5f4b46", "#604c47", "#634e48", "#21252e", "#535e72", "#535e72", "#1f232c", "#535e72", "#000000", "#ffffff", "#ffffff", "#ffffff"],
        ["#000000", "#000000", "#535e72", "#535e72", "#535e72", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#21242d", "#9e847b", "#9e847b", "#604c47", "#604c47", "#604c47", "#9e847b", "#9e847b", "#604c47", "#161d28", "#1f232c", "#21252e", "#535e72", "#1f232c", "#1f232c", "#535e72", "#1f232c", "#000000", "#000000", "#000000"],
        ["#000000", "#000000", "#535e72", "#535e72", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1d222b", "#9e847b", "#9e847b", "#9e847b", "#9e847b", "#9e847b", "#9e847b", "#20242c", "#1f232c", "#1c1f27", "#505b6f", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#535e72", "#535e72", "#535e72"],
        ["#000000", "#000000", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#9e847b", "#9e847b", "#9e847b", "#9e847b", "#604c47", "#1f232c", "#59657a", "#566176", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#1f232c", "#535e72", "#535e72", "#535e72"]
      ];

      // Characters for the cat's eyes
      const CAT_EYE_OPEN = "â€¢";
      const CAT_EYE_CLOSED = "-";
      const CAT_EYE_POKED = "0";

      const SMALL_DISPLAY_WARNING = "[b]It looks like you're on mobile or have a small display. Fyi the animation looks best viewed on a computer with a larger display.[/b]\n\n";

      // Website content
      const CONTENT = `

        Welcome to the personal homepage of [b]Takaki Oshima[/b].

        ${window.innerWidth < 800 ? SMALL_DISPLAY_WARNING : ''}
        [b]Work[/b]

        I'm an independent researcher. My interests span a bunch of domains including
         - Creative coding
         - Automated market making protocols
         - Quantitative trading and sports betting
         - AI

        In the past I worked as a SWE at [link https://google.com/]Google[/link] and as a quant trader at an HFT firm. I later cofounded a startup where I researched and built decentralized systems.


        [b]About this website[/b]

        This site is best viewed on a large display. It uses my favourite coding font, [link https://adobe-fonts.github.io/source-code-pro/]Source Code Pro[/link].

        It takes inspiration from the work of generative artists like [link https://ertdfgcvb.xyz/]Andreas Gysin[/link] and more generally from the field of generative art.

        The source code for this website can be found [link https://github.com/toshima/homepage]here[/link]. This site was last updated [i]March 2025[/i].


        [b]Socials[/b]

        I don't use social media much but I have accounts on [link https://github.com/toshima/]Github[/link] and (less actively) on [link https://x.com/takakioshima/]Twitter[/link] and [link https://www.linkedin.com/in/takakioshima/]LinkedIn[/link].


         /\\_/\\
        ( [eye]${CAT_EYE_CLOSED}[/eye].[eye]${CAT_EYE_CLOSED}[/eye] )
           ^
      `;

      // Remove leading whitespace from each line
      const dedent = (text) => {
        const lines = text.split('\n');
        const nonEmptyLines = lines.filter(line => line.trim());
        if (!nonEmptyLines.length) return text;

        const indentLength = Math.min(...nonEmptyLines.map(line => line.match(/^ */)[0].length));
        return lines.map(line => line.slice(indentLength)).join('\n');
      }

      // Convert pixels (a 2D array of RGB values) into an array of characters with formatting tags
      const getCharsFromPixels = pixels => {
        const chars = [];
        for (let y = 0; y < pixels.length - 1; y += 4) {
          for (let x = 0; x < pixels[y].length; x += 2) {
            const colors = [
              pixels[y][x], pixels[y][x+1], pixels[y+1][x], pixels[y+1][x+1], pixels[y+2][x], pixels[y+2][x+1], pixels[y+3][x], pixels[y+3][x+1]
            ]
            chars.push({
              id: `pixels-${y}-${x}`,
              char: ' ',
              tags: [{name: 'pixels', args: colors.map(c => c === "#ffffff" ? BACKGROUND_COLOR : c)}]
            });
          }
          chars.push({
            id: `pixels-${y}-newline`,
            char: '\n',
            tags: []
          });
        }
        return chars;
      }

      // Convert a string into an array of characters with formatting tags
      const getCharsFromText = (text) => {
        const chars = [];
        const activeTags = [];
        const codePoints = [...text]; // Split by unicode code points

        for (let i = 0; i < codePoints.length; i++) {
          if (codePoints[i] === '[' && codePoints.includes(']', i)) {
            const j = codePoints.indexOf(']', i);
            const tag = codePoints.slice(i + 1, j).join('');
            if (tag[0] === '/') {
              // Closing tag: [/tag]
              const tagName = tag.slice(1);
              const index = activeTags.findIndex(t => t.name === tagName);
              if (index !== -1) activeTags.splice(index, 1);
            } else {
              // Opening tag: [tag arg1 arg2]
              const [name, ...args] = tag.split(/\s+/);
              activeTags.push({name, args});
            }
            i = j;
            continue;
          }

          // Regular character
          chars.push({
            id: `text-${i}`,
            char: codePoints[i],
            tags: [...activeTags]
          });
        }
        return chars;
      }

      // Wrap text into lines of maximum width
      const wrapText = (chars, width) => {
        const lines = [];
        let line = [];

        for (const char of chars) {
          if (char.char === '\n') {
            lines.push(line);
            line = [];
            continue;
          }
          line.push(char);

          if (line.length > width) {
            const i = line.findLastIndex(char => char.char === ' ');
            if (i >= 0) {
              lines.push(line.slice(0, i));
              line = line.slice(i + 1);
            } else {
              lines.push(line);
              line = [];
            }
          }
        }

        if (line.length) lines.push(line);
        return lines;
      };

      const populateDOMElements = (chars) => {
        const container = document.getElementById('container');
        for (const char of chars) {
          const el = document.createElement('a');
          el.style.position = 'absolute';
          el.textContent = char.char;
          el.id = `char-${char.id}`;
          el.style.top = `${char.y * CHAR_HEIGHT}px`;
          el.style.left = `${char.x * CHAR_WIDTH}px`;
          el.style.minWidth = `${CHAR_WIDTH}px`;
          el.style.minHeight = `${CHAR_HEIGHT}px`;

          for (const {name, args} of char.tags) {
            if (name === 'link') {
              el.href = args[0];
            } else if (name === 'b') {
              el.style.fontWeight = 'bold';
            } else if (name === 'i') {
              el.style.fontStyle = 'italic';
            } else if (name === 'eye') {
              el.classList.add('eye');
            } else if (name === 'pixels') {
              el.classList.add('pixels');

              // Define colors
              args.forEach(color => {
                const colorElement = document.createElement('a');
                colorElement.style.background = color;
                el.appendChild(colorElement);
              });
            }
          }

          container.appendChild(el);
        }

        // Add invisible span in the bottom right corner so the container size is fixed
        const cornerElement = document.createElement('a');
        cornerElement.style.position = 'absolute';
        cornerElement.style.top = `${(numRows-1) * CHAR_HEIGHT}px`;
        cornerElement.style.left = `${(numColumns-1) * CHAR_WIDTH}px`;
        cornerElement.textContent = ' ';
        container.appendChild(cornerElement);
      }

      const animateChars = t => {
        const t0 = performance.now();
        if (t > charsState.nextFrameTime) {
          updateMouseVelocity();
          evolveChars();
          updateChars();
          charsState.nextFrameTime = t + INTERVAL_MS;
          charsState.frame++;
        }
        // if (charsState.frame % 100 === 0) {
        //   console.log(`Frame: ${charsState.frame} | Time: ${(performance.now() - t0).toFixed(2)}ms`);
        // }
        requestAnimationFrame(animateChars);
      }

      const updateMouseVelocity = () => {
        mouseState.velocityX *= 0.9;
        mouseState.velocityY *= 0.9;
        mouseState.velocityX += mouseState.x - mouseState.prevX;
        mouseState.velocityY += mouseState.y - mouseState.prevY;
        mouseState.prevX = mouseState.x;
        mouseState.prevY = mouseState.y;
      }

      const evolveChars = () => {
        const {frame, chars} = charsState;
        const t = Math.min(frame / EVOLVE_FRAMES, 1);
        const isAfterFinalFrame = frame >= EVOLVE_FRAMES;

        // Map to look up chars by their position
        const positionMap = {};
        chars.forEach(char => {
          const key = `${char.y},${char.x}`;
          positionMap[key] = char;
        });

        // Indices of positions that have already moved
        const frozenPositions = new Set();

        const moveChar = (char, y, x) => {
          positionMap[`${char.y},${char.x}`] = null;
          positionMap[`${y},${x}`] = char;
          frozenPositions.add(`${y},${x}`);
          char.y = y;
          char.x = x;

          if (isAfterFinalFrame && char.tags.some(tag => tag.name === 'eye')) {
            setCatEyes(CAT_EYE_POKED);
            lastPokeCatTime = t;
          }
        }

        // Sort so we process characters furthest from their target first
        // This reduces probability of characters getting stuck and not reaching their final position
        const sortedChars = [...chars].sort((a, b) => {
          const distA = Math.abs(a.finalY - a.y) + Math.abs(a.finalX - a.x);
          const distB = Math.abs(b.finalY - b.y) + Math.abs(b.finalX - b.x);

          // Add a bit of randomness to help not get stuck
          return distB - distA + sampleUniform(-3, 3);
        });

        // Freeze links when mouse is nearby
        // A bit hacky but works
        for (const char of sortedChars) {
          const mouseDx = mouseState.x / CHAR_WIDTH - char.x;
          const mouseDy = mouseState.y / CHAR_HEIGHT - char.y;
          const mouseDist = Math.hypot(mouseDx, mouseDy);
          if (
            isAfterFinalFrame
            && char.tags.some(tag => tag.name === 'link')
            && char.finalY === char.y && char.finalX === char.x
            && mouseDist < 0.05 * numColumns
          ) {
            frozenPositions.add(`${char.y},${char.x}`);
          }
        }

        for (const char of sortedChars) {
          if (frozenPositions.has(`${char.y},${char.x}`)) {
            continue;
          }

          // How much we want to move the character. We'll adjust this value throughout this function.
          let deltaX = 0;
          let deltaY = 0;

          // Pull towards final position. Starts at time 0.25 - 0.75 depending on weight and ends at time 1
          const finalPullWeight = Math.max(0, (t - 0.75 + char.weight * 0.5) / 0.75);
          deltaX += finalPullWeight * (char.finalX - char.x);
          deltaY += finalPullWeight * (char.finalY - char.y);

          // Add rotation around center. Ramps down from time 0 to time 0.8.
          // Add some jitter to the center of rotation to help prevent characters from getting stuck in the middle.
          const viewportCenterX = window.scrollX + window.innerWidth / 2;
          const viewportCenterY = window.scrollY + window.innerHeight / 2;
          const centerDx = viewportCenterX / CHAR_WIDTH - char.x + 0.1 * sampleGaussian();
          const centerDy = viewportCenterY / CHAR_HEIGHT - char.y + 0.1 * sampleGaussian();
          const centerDist = Math.hypot(centerDx, centerDy);
          if (centerDist > 0) {
            const centerRotationWeight = Math.max(0, 0.8 - t) / 0.8;
            deltaX += centerRotationWeight * centerDy / centerDist;
            deltaY += centerRotationWeight * -centerDx / centerDist;
          }

          // Add mouse influence
          const mouseDx = mouseState.x / CHAR_WIDTH - char.x;
          const mouseDy = mouseState.y / CHAR_HEIGHT - char.y;
          const mouseDist = Math.hypot(mouseDx, mouseDy);
          const maxMouseDist = 6;
          if (mouseDist / maxMouseDist < 1 - char.weight && mouseState.seen) { // Only affect characters within range
            const mouseSpeed = Math.hypot(mouseState.velocityX / CHAR_WIDTH, mouseState.velocityY / CHAR_HEIGHT);
            const mouseSpeedWeight = Math.min(mouseSpeed / 100, 1);
            deltaX += 100 * (1 - char.weight) * mouseSpeedWeight / mouseDist * mouseDx;
            deltaY += 100 * (1 - char.weight) * mouseSpeedWeight / mouseDist * mouseDy;

            deltaX += 300 * (1 - char.weight) * mouseSpeedWeight * mouseState.velocityX / mouseSpeed;
            deltaY += 300 * (1 - char.weight) * mouseSpeedWeight * mouseState.velocityY / mouseSpeed;

            // Add clockwise curl effect around mouse
            // deltaX += 20 * -mouseSpeedWeight * mouseDy / mouseDist; 
            // deltaY += 20 * mouseSpeedWeight * mouseDx / mouseDist;
          }

          // Explosion
          // if (frame === Math.floor(0.5 * EVOLVE_FRAMES)) {
          //   console.log('exploding');
          //   char.driftX += -centerDx / centerDist;
          //   char.driftY += -centerDy / centerDist;
          // }

          // Drift
          // const driftProb = 0.001;// * Math.max(0, 1 - t);
          // if (Math.random() < driftProb && t < 1) {
          //   char.driftX += Math.random() < 0.5 ? sampleUniform(-1, 1) : 0;
          //   char.driftY += Math.random() < 0.5 ? sampleUniform(-1, 1) : 0;
          // }
          // deltaX += 100 * char.driftX;
          // deltaY += 100 * char.driftY;
          // char.driftX *= t < 1 ? 0.99 : 0.8;
          // char.driftY *= t < 1 ? 0.99 : 0.8;

          // If it doesn't move much, just skip and mark it as frozen
          if (Math.hypot(deltaX, deltaY) < 0.001) {
            frozenPositions.add(`${char.y},${char.x}`);
            continue;
          }

          // Move character one step in the direction of the force, adding a bit of randomness
          const theta = Math.atan2(deltaY, deltaX) + sampleUniform(-Math.PI / 4, Math.PI / 4);
          const diagonalMoveAllowed = true;
          const angleStep = diagonalMoveAllowed ? Math.PI / 4 : Math.PI / 2;
          const discretizedTheta = Math.round(theta / angleStep) * angleStep;

          // Calculate direction of movement based on theta
          const newY = (char.y + Math.round(Math.sin(discretizedTheta)) + numRows) % numRows;
          const newX = (char.x + Math.round(Math.cos(discretizedTheta)) + numColumns) % numColumns;

          // If there is a character and it has already moved, don't move this character
          const key = `${newY},${newX}`;
          if (frozenPositions.has(key)) {
            continue;
          }

          // Check to see if there's already a character in the position we want to move to
          // Swap positions with target character if it exists
          const targetChar = positionMap[key];
          if (targetChar) {
            moveChar(targetChar, char.y, char.x);
          }

          moveChar(char, newY, newX);
        }
      };

      const updateChars = () => {
        const container = document.getElementById('container');
        for (const char of charsState.chars) {
          const span = document.getElementById(`char-${char.id}`);
          span.style.top = `${char.y * CHAR_HEIGHT}px`;
          span.style.left = `${char.x * CHAR_WIDTH}px`;
        }
      }

      // Make the cat's eyes blink
      const animateCat = t => {
        if (t > catState.nextFrameTime + INTERVAL_MS && t > catState.lastPokeCatTime + 1500) {
          catState.catEyesOpen = !catState.catEyesOpen;

          // Update all eye elements
          const eye = catState.catEyesOpen ? CAT_EYE_OPEN : CAT_EYE_CLOSED;
          setCatEyes(eye);

          // Wait a random log-normally distributed length of time
          // Eyes stay open longer than they stay closed
          const waitSd = 0.7;
          const waitMultiplier = catState.catEyesOpen ? 2 : 0.15;
          const wait = Math.exp(waitSd * sampleGaussian()) * waitMultiplier * 1000;
          catState.nextFrameTime = t + wait;
        }

        requestAnimationFrame(animateCat);
      }

      const setCatEyes = eye => {
        const spans = document.querySelectorAll('.eye');
        spans.forEach(span => {
          span.textContent = eye;
        });
      }

      // Random sampling functions
      const sampleUniform = (min, max) => min + Math.random() * (max - min);
      const sampleUniformInt = (min, max) => Math.floor(sampleUniform(min, max + 1));
      const sampleExponential = lambda => -Math.log(Math.random()) / lambda;

      // Box-Muller transform for sampling from a Gaussian distribution
      const sampleGaussian = () => {
        const r = Math.sqrt(sampleExponential(2));
        const theta = 2 * Math.PI * Math.random();
        return r * Math.cos(theta);
      }

      // Set background color
      document.body.style.background = BACKGROUND_COLOR;

      // Mouse state
      const mouseState = {
        x: 0,
        y: 0,
        prevX: 0,
        prevY: 0,
        velocityX: 0,
        velocityY: 0,
        seen: false
      };
      document.addEventListener('mousemove', (e) => {
        mouseState.x = e.pageX;
        mouseState.y = e.pageY;
        mouseState.seen = true;
      });

      // Calculate number of columns and min rows based on window size
      // Subtract 2 so that the horizontal scrollbar doesn't show up
      const minRows = Math.floor(window.innerHeight / CHAR_HEIGHT);
      const numColumns = Math.floor(window.innerWidth / CHAR_WIDTH) - 2;

      // Parse the website text and wrap it into lines
      let chars = [
        ...getCharsFromPixels(PFP_IMAGE),
        ...getCharsFromText(dedent(CONTENT))
      ];

      // Calculate number of columns to wrap text into
      // It's between 60% and 80% depending on the window width
      const sizeWeight = Math.min(1, Math.max(0, (window.innerWidth - 600) / 1000));
      const numWrapColumns = Math.ceil(numColumns * (0.6 * sizeWeight + 0.8 * (1 - sizeWeight)));

      // Wrap the text into lines and attach final positions
      const lines = wrapText(chars, numWrapColumns);
      const numRows = Math.max(minRows, lines.length + 8);
      const startY = Math.max(5, Math.floor((numRows - lines.length) * 0.4));
      const startX = Math.floor((numColumns - numWrapColumns) * 0.5);
      for (let y = 0; y < lines.length; y++) {
        for (let x = 0; x < lines[y].length; x++) {
          const char = lines[y][x];
          char.finalY = y + startY;
          char.finalX = x + startX;
        }
      }

      // Remove chars not assigned a final position, such as spaces that were wrapped
      chars = chars.filter(c => c.finalX !== undefined && c.finalY !== undefined);

      // Remove whitespace chars
      chars = chars.filter(c => (c.char !== ' ' && c.char !== '\n') || c.tags.length > 0);

      // Set initial positions and weights
      for (const char of chars) {
        char.y = sampleUniformInt(0, numRows);
        char.x = sampleUniformInt(0, numColumns);
        char.weight = sampleUniform(0, 1);
        char.driftY = 0;
        char.driftX = 0;
      }

      const charsState = {
        frame: 0,
        nextFrameTime: 0,
        chars,
        minRows,
        numColumns,
        numWrapColumns,
      }

      const catState = {
        nextFrameTime: 0,
        catEyesOpen: false,
        lastPokeCatTime: 0,
      };

      populateDOMElements(chars);
      requestAnimationFrame(animateChars);
      requestAnimationFrame(animateCat);
    }

    document.fonts.ready.then(dance);
  </script>
</body>
</html>