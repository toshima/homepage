<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Takaki Oshima's homepage">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap">
  <title>Takaki Oshima's homepage</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Source Code Pro', monospace;
      font-size: 15px;
      color: #222222;
    }
    #container {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow: auto;
      line-height: 1.35;
      white-space: pre;
    }
    #container a {
      color: inherit; /* Don't colorize links */
    }
    .pixels {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(4, 1fr);
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    document.fonts.ready.then(() => {
      // Remove leading whitespace from each line
      const dedent = (text) => {
        const lines = text.split('\n');
        const nonEmptyLines = lines.filter(line => line.trim());
        if (!nonEmptyLines.length) return text;

        const indentLength = Math.min(...nonEmptyLines.map(line => line.match(/^ */)[0].length));
        return lines.map(line => line.slice(indentLength)).join('\n');
      }

      const config = {
        fontSize: 15,
        charWidth: 15 * 0.6,
        charHeight: 15 * 1.35,
        backgroundColor: "#ffebf4",
        maxFrame: 300, // Number of frames to evolve the characters for.
        maxStartFrame: 150, // Maximum number of frames to wait before starting to move a character.
        intervalMs: 15, // Interval between steps in the animation. Determines how fast the characters move.
        content: dedent(`

          Welcome to the personal homepage of [b]Takaki Oshima[/b].


          [b]Work[/b]

          I'm an independent researcher. My interests span a bunch of domains including:
           - Creative coding
           - Automated market making protocols
           - Quantitative trading and sports betting
           - AI

          In the past I worked at [link https://google.com/]Google[/link] and as an HFT quant. Later, I cofounded a startup where I researched and built decentralized systems.


          [b]About this website[/b]

          The source code for this site can be found [link https://github.com/toshima/homepage]here[/link]. It takes inspiration from the work of generative artists like [link https://ertdfgcvb.xyz/]Andreas Gysin[/link].

          Last updated [i]March 2025[/i].


          [b]Socials[/b]

          I don't use social media much but I have accounts on [link https://github.com/toshima/]GitHub[/link] and (less actively) on [link https://x.com/takakioshima/]Twitter[/link] and [link https://www.linkedin.com/in/takakioshima/]LinkedIn[/link].

        `),
        pfpImage: {
          columns: 32,
          colors: ['#000000', '#020302', '#050608', '#060709', '#08090d', '#090a0b', '#0a0a0a', '#161d28', '#1a1c20', '#1c1f27', '#1d222b', '#1f232c', '#20242c', '#21242d', '#21252e', '#28314c', '#2a1511', '#311c17', '#34201b', '#34201c', '#35211c', '#36211a', '#36211b', '#36211c', '#36221d', '#37221c', '#37221d', '#38211c', '#38231e', '#382420', '#384571', '#3a251f', '#3c4872', '#3d4a74', '#3e4b76', '#3f4c77', '#3f4d78', '#404d78', '#404d79', '#424755', '#42507d', '#43507b', '#453836', '#4e4644', '#50484a', '#505b6f', '#535e72', '#566176', '#59657a', '#5a4b47', '#5c4d49', '#5f4b46', '#604b47', '#604c47', '#634e48', '#65514c', '#765e56', '#765e58', '#774a49', '#828fb5', '#947167', '#997f77', '#9a8077', '#9c8279', '#9c9c9c', '#9e847b', '#a0867c', '#a57975', '#a57c76', '#a58b81', '#a5b2d3', '#ac676e', '#adbadd', '#b1bee2', '#d3b8af', '#d8bdb4', '#d9beb5', '#dabfb6', '#dbc0b7', '#ddc2b9', '#dfc9c2', '#e1c6bd', '#e3c8be', '#ffffff'],
          image: 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\x00\x00SSSSSSSSSSSSSSSSSSSSSSSSS@\x00\x00\x00\x00HH\x00\x00\x00SSSSSSSSSSSSSSSSSSSSS\x00\'HHHH###HH\x00\x00SSSSSSSSSSSSSSSSSS\x00I;##########(\x06SSSSSSSSSSSSSSSSS\x00&############ \x00SSSSSSSSSSSSSSS\x00$#######HH#### \x00SSSSSSSSSSSSSSS\x00$###"HHHHHH%## \x00SSSSSSSSSSSSSSS\x00$#####HHHHH%#\x1eF\x00SSSSSSSSSSSSSS\x00####!\x03\x03\x03\x03\x03\x03\x03\x03\x03\x01)H\x00SSSSSSSSSSSSS\x00###\x0f\x03\x02\x08+\x08\x05\x05\x05\x05\x05\x05\x04#\x00SSSSSSSSSSSSS\x00###\x0f\x03\x1a\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x00SSSSSSSSSSSSS\x00##\x15\x1a\x1fN\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x13\x03\x00SSSSSSSSSSSSS\x00##\x159KA*1A<<5*22\x13\x03\x00SSSSSSSSSSSSS\x00#\x16OMMMAAAPPA5EA=\x1a\x00SSSSSSSSSSSSS\x00#\x16OMMMMAAPPAAA>J\x1a\x00SSSSSSSSSSSSS\x00#\x16OMMMMMMPPMAQMJ\x1a\x00SSSSSSSSSSSS\x00.\x0b\x19OMMMMMPPPPMMR\x12\x00SSSSSSSSSSSS\x00..\x0b\x0b\x149MMMM<<<<LMR\x12\x00SSSSSSSSSSSS\x00..\x0b\x0b\x149MMMMMA5ALMR\x1d.\x00SSSSSSSSSSS\x00..\x0b\x0b\x149MMMAADCAAQR\x18\x0b.\x00SSSSSSS\x00\x00\x00...\x0b\x0bB8\x1fN5::GG:4\x11\x1b\x0e..\x00SSSSSSS\x00...\x0b.\x0b\x0bBA?\x17AAA55AA\x10\x1b\x0e...\x00SSSSSS\x00...\x0b\x0b\x0b\x0b\x0b,?\x17AMMAAM\x1c76\x0e...\x00SSSSSS\x00..\x0b\x0b\x0b\x0b\x0b\x0b,AA\x1a\x1a\x1a\x1a\x1a\x1a356\x0e..\x0b.\x00SSS\x00\x00...\x0b\x0b\x0b\x0b\x0b\x0b\x0b\rAA555AA5\x07\x0b\x0e.\x0b\x0b.\x0b\x00\x00\x00\x00\x00..\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\nAAAAAA\x0c\x0b\t-\x0b\x0b\x0b\x0b\x0b...\x00\x00\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0bAAAA5\x0b0/\x0b\x0b\x0b\x0b\x0b\x0b...',
        },
      };

      const state = {
        chars: [],
        numRows: 0,
        numColumns: 0,
        frame: 0,
        nextFrameTime: 0,
      };

      // Decode a pixel image into a 2D array of hex strings
      // `colors` is an array of hex colors, and `image` is a string of characters whose ASCII values map to the colors
      // `columns` is the number of columns in the image
      const decodeImage = ({columns, colors, image}) => {
        const decoded = image.split('').map(c => colors[c.charCodeAt(0)]);
        const pixels = [];
        for (let i = 0; i < decoded.length; i += columns) {
          pixels.push(decoded.slice(i, i + columns));
        }
        return pixels;
      }

      // Convert pixels (a 2D array of hex strings) into an array of characters with formatting tags
      const getCharsFromImage = (pixels) => {
        const chars = [];
        for (let y = 0; y < pixels.length - 1; y += 4) {
          for (let x = 0; x < pixels[y].length; x += 2) {
            const colors = [
              pixels[y][x], pixels[y][x+1], pixels[y+1][x], pixels[y+1][x+1], pixels[y+2][x], pixels[y+2][x+1], pixels[y+3][x], pixels[y+3][x+1]
            ]
            chars.push({
              id: `pixels-${y}-${x}`,
              char: ' ',
              tags: [{name: 'pixels', args: colors.map(c => c === "#ffffff" ? config.backgroundColor : c)}]
            });
          }
          chars.push({
            id: `pixels-${y}-newline`,
            char: '\n',
            tags: []
          });
        }
        return chars;
      }

      // Convert a string into an array of characters with formatting tags
      const getCharsFromText = (text) => {
        const chars = [];
        const activeTags = [];
        const codePoints = [...text]; // Split by unicode code points

        for (let i = 0; i < codePoints.length; i++) {
          if (codePoints[i] === '[' && codePoints.includes(']', i)) {
            const j = codePoints.indexOf(']', i);
            const tag = codePoints.slice(i + 1, j).join('');
            if (tag[0] === '/') {
              // Closing tag: [/tag]
              const tagName = tag.slice(1);
              const index = activeTags.findIndex(t => t.name === tagName);
              if (index !== -1) activeTags.splice(index, 1);
            } else {
              // Opening tag: [tag arg1 arg2]
              const [name, ...args] = tag.split(/\s+/);
              activeTags.push({name, args});
            }
            i = j;
            continue;
          }

          // Regular character
          chars.push({
            id: `text-${i}`,
            char: codePoints[i],
            tags: [...activeTags]
          });
        }
        return chars;
      }

      // Wrap text into lines of maximum width
      const wrapText = (chars, width) => {
        const lines = [];
        let line = [];

        for (const char of chars) {
          if (char.char === '\n') {
            lines.push(line);
            line = [];
            continue;
          }
          line.push(char);

          if (line.length > width) {
            const i = line.findLastIndex(char => char.char === ' ');
            if (i >= 0) {
              lines.push(line.slice(0, i));
              line = line.slice(i + 1);
            } else {
              lines.push(line);
              line = [];
            }
          }
        }

        if (line.length) lines.push(line);
        return lines;
      };

      const generateChars = () => {
        // Calculate number of columns and min rows based on window size
        // Subtract 2 so that the horizontal scrollbar doesn't show up
        const minRows = Math.floor(window.innerHeight / config.charHeight);
        let numColumns = Math.floor((window.innerWidth-1) / config.charWidth);

        // Enforce a minimum number of columns
        if (numColumns < 25) {
          numColumns = 30;
        }

        // Parse the website text and wrap it into lines
        const unwrappedChars = [
          ...getCharsFromImage(decodeImage(config.pfpImage)),
          ...getCharsFromText(config.content),
        ];

        // Calculate number of columns to wrap text into
        // It's between 60% and 80% depending on the window width
        const sizeWeight = Math.min(1, Math.max(0, (window.innerWidth - 600) / 1000));
        const numWrapColumns = Math.ceil(numColumns * (0.6 * sizeWeight + 0.8 * (1 - sizeWeight)));

        // Wrap the text into lines and attach final positions
        const lines = wrapText(unwrappedChars, numWrapColumns);
        const numRows = Math.max(minRows, lines.length + 8);
        const startY = Math.max(5, Math.floor((numRows - lines.length) * 0.4));
        const startX = Math.floor((numColumns - numWrapColumns) * 0.5);

        const chars = [];
        for (let y = 0; y < lines.length; y++) {
          for (let x = 0; x < lines[y].length; x++) {
            const char = lines[y][x];
            if ((char.char === ' ' || char.char === '\n') && char.tags.length === 0) {
              continue;
            }
            char.x = startX + x;
            char.y = startY + y;
            char.velocityX = 0;
            char.velocityY = 0;
            char.path = [{x: char.x, y: char.y}];
            char.startFrame = sample.uniformInt(0, config.maxFrame - config.maxStartFrame);
            chars.push(char);
          }
        }

        state.chars = chars;
        state.numRows = numRows;
        state.numColumns = numColumns;
      }

      const createCharElement = (char) => {
        const {charWidth, charHeight} = config;
        const el = document.createElement('a');
        el.style.position = 'absolute';
        el.style.top = `${char.y * charHeight}px`;
        el.style.left = `${char.x * charWidth}px`;
        el.style.minWidth = `${charWidth}px`;
        el.style.minHeight = `${charHeight}px`;
        el.textContent = char.char;
        el.id = `char-${char.id}`;

        for (const {name, args} of char.tags) {
          if (name === 'link') {
            el.href = args[0];
          } else if (name === 'b') {
            el.style.fontWeight = 'bold';
          } else if (name === 'i') {
            el.style.fontStyle = 'italic';
          } else if (name === 'pixels') {
            el.classList.add('pixels');
            args.forEach(color => {
              const colorElement = document.createElement('a');
              colorElement.style.background = color;
              el.appendChild(colorElement);
            });
          }
        }
        return el;
      }

      // Add invisible span in the bottom right corner so the container size is fixed
      const createCornerElement = () => {
        const {charWidth, charHeight} = config;
        const {numRows, numColumns} = state;
        const corner = document.createElement('a');
        corner.style.position = 'absolute';
        corner.style.top = `${(numRows-1) * charHeight}px`;
        corner.style.left = `${(numColumns-1) * charWidth}px`;
        corner.textContent = ' ';
        return corner;
      }

      const animateGrid = (t) => {
        if (t > state.nextFrameTime) {
          state.chars.forEach(({id, path}) => {
            const el = document.getElementById(`char-${id}`);
            const {x, y} = path[Math.max(path.length - 1 - state.frame, 0)];
            el.style.top = `${y * config.charHeight}px`;
            el.style.left = `${x * config.charWidth}px`;
          });
          state.nextFrameTime = t + config.intervalMs;
          state.frame++;
        }
        requestAnimationFrame(animateGrid);
      }

      const runSimulation = () => {
        const {frame, chars, numRows, numColumns} = state;
        const {charWidth, charHeight, maxFrame} = config;
        const t = Math.min(frame / maxFrame, 1);
        const isAfterFinalFrame = frame >= maxFrame;
        const heightWidthRatio = charHeight / charWidth;

        // Map to look up chars by their position
        const positionMap = {};
        chars.forEach(char => {
          const key = `${char.y},${char.x}`;
          positionMap[key] = char;
        });

        // Indices of positions that have already moved
        const occupiedPositions = new Set();

        const moveChar = (char, {x, y}) => {
          positionMap[`${char.y},${char.x}`] = null;
          positionMap[`${y},${x}`] = char;
          occupiedPositions.add(`${y},${x}`);
          char.y = y;
          char.x = x;
          char.path.push({x, y});
        }

        for (let frame = 0; frame < config.maxFrame; frame++) {
          occupiedPositions.clear();

          // Sort so we process characters furthest from their target first
          // This reduces probability of characters getting stuck and not reaching their final position
          const sortedChars = [...chars].sort((a, b) => {
            const distA = Math.abs(a.finalY - a.y) + Math.abs(a.finalX - a.x);
            const distB = Math.abs(b.finalY - b.y) + Math.abs(b.finalX - b.x);

            // Add a bit of randomness to help not get stuck
            return distB - distA + sample.uniform(-3, 3);
          });

          for (const char of sortedChars) {
            // If the character is frozen, don't move it
            if (occupiedPositions.has(`${char.y},${char.x}`)) {
              continue;
            }

            if (frame < char.startFrame) {
              occupiedPositions.add(`${char.y},${char.x}`);
              continue;
            }

            // How much we want to move the character. We'll adjust this value throughout this function.
            const moveVector = {x: char.velocityX, y: char.velocityY};

            // Curl clockwise around viewport center
            const centerVector = {
              x: (window.scrollX + window.innerWidth / 2) / charWidth - char.x + 0.1 * sample.gaussian(),
              y: heightWidthRatio * ((window.scrollY + window.innerHeight / 2) / charHeight - char.y + 0.1 * sample.gaussian()),
            };
            const centerDistance = Math.hypot(centerVector.x, centerVector.y);
            if (centerDistance > 0) {
              const w = Math.max(0, 0.8 - t) / 0.8;
              moveVector.x += w * centerVector.y / centerDistance;
              moveVector.y += w * -centerVector.x / centerDistance;
            }

            // Momentum
            char.velocityX = 0.95 * char.velocityX + 0.05 * moveVector.x;
            char.velocityY = 0.99 * char.velocityY + 0.01 * moveVector.y;

            // If the character is not moving, freeze it
            if (Math.hypot(moveVector.x, moveVector.y) < 0.001) {
              occupiedPositions.add(`${char.y},${char.x}`);
              continue;
            }

            // Move character one step in the direction of the force, adding a bit of randomness
            const theta = Math.atan2(moveVector.y, moveVector.x) + sample.uniform(-Math.PI / 4, Math.PI / 4);
            const angleStep = Math.PI / 4;
            const discretizedTheta = Math.round(theta / angleStep) * angleStep;

            // Calculate direction of movement based on theta
            const newPosition = {
              x: (char.x + Math.round(Math.cos(discretizedTheta)) + numColumns) % numColumns,
              y: (char.y + Math.round(Math.sin(discretizedTheta)) + numRows) % numRows,
            }

            // If there is a character and it has already moved, don't move this character
            const key = `${newPosition.y},${newPosition.x}`;
            if (occupiedPositions.has(key)) {
              continue;
            }

            // Check to see if there's already a character in the position we want to move to
            // Swap positions with target character if it exists
            const targetChar = positionMap[key];
            if (targetChar) {
              moveChar(targetChar, char);
            }
            moveChar(char, newPosition);
          }
        }
      };

      const sample = {
        uniform: (min, max) => min + Math.random() * (max - min),
        uniformInt: (min, max) => Math.floor(sample.uniform(min, max + 1)),
        exponential: lambda => -Math.log(Math.random()) / lambda,
        gaussian: () => {
          const r = Math.sqrt(sample.exponential(2));
          const theta = 2 * Math.PI * Math.random();
          return r * Math.cos(theta);
        },
      }

      const startDance = () => {
        document.body.style.background = config.backgroundColor;

        generateChars();
        runSimulation();

        // Create DOM elements
        const container = document.getElementById('container');
        const elements = [...state.chars.map(createCharElement), createCornerElement()];
        elements.forEach(element => container.appendChild(element));

        // Start animation
        requestAnimationFrame(animateGrid);
      };

      startDance();
    });
  </script>
</body>
</html>